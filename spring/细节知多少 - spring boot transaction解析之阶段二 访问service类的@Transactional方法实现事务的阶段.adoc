= ç»†èŠ‚çŸ¥å¤šå°‘ - spring boot transactionè§£æä¹‹é˜¶æ®µäºŒ è®¿é—®serviceç±»çš„@Transactionalæ–¹æ³•å®ç°äº‹åŠ¡çš„é˜¶æ®µ
:toc: left
:toc-title: ç›®å½•
:tip-caption: ğŸ’¡
:note-caption: â„¹ï¸
:important-caption: â—
:caution-caption: ğŸ”¥
:warning-caption: âš ï¸
// :tip-caption: :bulb:
// :note-caption: :information_source:
// :important-caption: :heavy_exclamation_mark:	
// :caution-caption: :fire:
// :warning-caption: :warning:
:icons: font

Doc writer yaoyihao1@gmail.com


== æ¦‚è¿°
spring boot transactionæˆ‘ä»¬å¹³æ—¶ç”¨ç€éå¸¸ç®€å•ï¼Œåªéœ€è¦åœ¨serviceæ–¹æ³•ä¸Šå£°æ˜@Transactionalå°±å¯ä»¥äº†ã€‚ä½†æ˜¯è¦çŸ¥é“ï¼Œç®€å•çš„èƒŒåæ˜¯ä¸ç®€å•ï¼Œåªæ˜¯å¾ˆå¤šä¸œè¥¿springæ¡†æ¶å¸®æˆ‘ä»¬åšå¥½äº†ã€‚å¦‚æœæƒ³è¿›é˜¶ï¼Œæƒ³è¿›æ­¥ï¼Œæƒ³å¼„æ‡‚ï¼Œæƒ³å­¦ä¹ ï¼Œéœ€è¦æ¥è¿‘å®ƒï¼Œäº†è§£å®ƒï¼Œå¼„æ‡‚å®ƒï¼Œæœ€å¥½çš„æ–¹æ³•è«è¿‡äºdebugå®ƒçš„æºç äº†ã€‚

ç¬”è€…æŠŠspring boot transactionçš„æ•´ä¸ªè¿‡ç¨‹åˆ†ä¸ºä¸¤ä¸ªé˜¶æ®µ

1. å¸¦æœ‰@Transactionalæ–¹æ³•çš„serviceç±»ç”Ÿæˆä»£ç†ç±»çš„é˜¶æ®µ
2. è®¿é—®serviceç±»çš„@Transactionalæ–¹æ³•å®ç°äº‹åŠ¡çš„é˜¶æ®µ
æœ¬æ–‡æˆ‘ä»¬äº§å‡ºç¬¬äºŒé˜¶æ®µï¼šè®¿é—®serviceç±»çš„@Transactionalæ–¹æ³•å®ç°äº‹åŠ¡çš„é˜¶æ®µ


== æŠ€æœ¯æ ˆ

----
spring boot 1.5.10
spring framework 4.3.14
----


== å¸¦ç€é—®é¢˜å­¦ä¹ 

[tip]
å¸¦ç€é—®é¢˜å­¦ä¹ å¾€å¾€èµ·åˆ°æ›´å¥½çš„æ•ˆæœ

é—®é¢˜ï¼š

----
1. å¹³æ—¶æ€»æ˜¯springé»˜è®¤çš„äº‹åŠ¡åªæœ‰è¿è¡Œæ—¶å¼‚å¸¸æ‰å›æ»šï¼Œä¸ºä»€ä¹ˆ
2. äº‹åŠ¡çš„savepointæ˜¯ä»€ä¹ˆ
3. å¦‚ä½•åšåˆ°å¤šä¸ªæ•°æ®æ“ä½œçš„äº‹åŠ¡æäº¤å’Œå›æ»šçš„
----


== è°ƒç”¨æµç¨‹å›¾

image::https://raw.githubusercontent.com/yaoyuanyy/MarkdownPhotos/master/img/20201129090652.png[20201129090652]

è¿™æ˜¯springå®˜ç½‘docä¸Šå…³äºspring transactionçš„è°ƒç”¨æµç¨‹å›¾ã€‚æˆ‘ä»¬å¤§è‡´å…ˆæœ‰ä¸ªå°è±¡ï¼Œæ¯ä¸ªèŠ‚ç‚¹çš„ç»†èŠ‚æ­£æ˜¯æœ¬æ–‡çš„é‡ç‚¹å†…å®¹ã€‚éšç€æœ¬æ–‡ç»†èŠ‚çš„é€ä¸€é˜è¿°å®Œæˆï¼Œå†å›æ¥çœ‹ä¸‹è¿™ä¸ªå›¾ï¼Œä¼šæœ‰æ›´æ·±çš„ç†è§£å’ŒæŒæ¡


== http è®¿é—®

- http://localhost:2372/user/updateSchoolName?schoolName=vl&studentId=3

å½“ä»controllerè®¿é—®serviceçš„æ–¹æ³•æ—¶ï¼Œå› ä¸ºcontrollerå¼•ç”¨çš„serviceæŒ‡å‘çš„ä»£ç†ç±»ï¼Œæ‰€ä»¥è¿›å»ä»£ç†ç±»çš„æ–¹æ³•ï¼Œå¦‚ä¸‹


=== ä»£ç†ç±»çš„æ–¹æ³•

è¿™é‡Œæˆ‘ä»¬ä»¥UserServiceçš„updateSchoolNameä¸ºä¾‹ï¼Œä¸‹é¢ä»£ç ä¸ºUserServiceçš„updateSchoolNameæ–¹æ³•ç”Ÿæˆçš„ä»£ç†ç±»çš„æ–¹æ³•ï¼Œvar10000å³æ˜¯DynamicAdvisedInterceptorç±»

----
final void CGLIB$updateSchoolName$4(String var1, long var2) {
	super.updateSchoolName(var1, var2);
}

public final void updateSchoolName(String var1, long var2) {
	try {
		MethodInterceptor var10000 = this.CGLIB$CALLBACK_0;
		if (var10000 == null) {
			CGLIB$BIND_CALLBACKS(this);
			var10000 = this.CGLIB$CALLBACK_0;
		}

		if (var10000 != null) {
			var10000.intercept(this, CGLIB$updateSchoolName$4$Method, new Object[]{var1, new Long(var2)}, CGLIB$updateSchoolName$4$Proxy);
		} else {
			super.updateSchoolName(var1, var2);
		}
	} catch (Error | RuntimeException var4) {
		throw var4;
	} catch (Throwable var5) {
		throw new UndeclaredThrowableException(var5);
	}
}
----

ä»è¿™ä¸ªæ–¹æ³•æˆ‘ä»¬çŸ¥é“ï¼Œç¨‹åºä¼šè¿›å»var10000.interceptï¼Œå³DynamicAdvisedInterceptor.interceptæ–¹æ³•ï¼Œæˆ‘ä»¬çœ‹çœ‹è¿™ä¸ªæ–¹æ³•å†…éƒ¨ä»£ç 

----
public Object intercept(Object proxy, Method method, Object[] args, MethodProxy methodProxy) throws Throwable {
	Object oldProxy = null;
	Class<?> targetClass = null;
	Object target = null;
	try {
		if (this.advised.exposeProxy) {
			oldProxy = AopContext.setCurrentProxy(proxy);
		}
		
		List<Object> chain = this.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass);
		Object retVal;
		
		if (chain.isEmpty() && Modifier.isPublic(method.getModifiers())) {
			Â·Â·Â·Â·Â·Â·
		}
		else {
			retVal = new CglibMethodInvocation(proxy, target, method, args, targetClass, chain, methodProxy).proceed(); // (1)
		}
		retVal = processReturnType(proxy, target, method, retVal);
		return retVal;
	}
	finally {
		Â·Â·Â·Â·Â·Â·
	}
}
----

åœ¨è¿™ä¸ªæ–¹æ³•ä¸­ï¼Œä¼šåˆ›å»ºCglibMethodInvocationå®ä¾‹ï¼Œproxy, targetï¼Œchainç­‰å‚æ•°ä¼ ç»™å®ƒï¼Œç„¶åè°ƒåŠ¨proceed()æ–¹æ³•ã€‚è¿™é‡Œè¿ç”¨äº†ä¸€ä¸ªè®¾è®¡æ¨¡å¼ï¼š *è´£ä»»é“¾æ¨¡å¼çš„å˜ç§* ï¼ŒCglibMethodInvocationæ‹¥æœ‰ä¸€ä¸ªMethodInterceptoré›†åˆï¼Œé€šè¿‡proceed()æ–¹æ³•æ‰§è¡Œinterceptor chainã€‚proceed()ä¼šéå†interceptorsAndDynamicMethodMatchers(å…¶å®å°±æ˜¯interceptoré›†åˆ)ä»è€Œæ‰§è¡Œæ¯ä¸ªinterceptor.invoke(MethodInvocation)è‡ªèº«çš„é€»è¾‘ï¼Œå› ä¸ºè¿™ä¸ªæ—¶å€™MethodInvocationä¼šä¼ é€’ç»™invokeæ–¹æ³•ï¼Œæ‰€ä»¥æ¯ä¸€ä¸ªinvokeæ–¹æ³•å†…éƒ¨éƒ½ä¼šæ‰§è¡ŒMethodInvocation.proceed()ï¼Œä»è€Œè¿™æ ·å½¢æˆäº†ä¸€ä¸ªé“¾å¼çš„è°ƒç”¨å…³ç³»ã€‚æˆ‘ä»¬çœ‹ä¸‹é“¾å¼ä»£ç ç»“æ„


----
MethodInvocationç±»
public Object proceed() throws Throwable {
    // é“¾å¼è°ƒç”¨ç»ˆç»“ç‚¹
    if (this.currentInterceptorIndex == this.interceptorsAndDynamicMethodMatchers.size() - 1) {
        return invokeJoinpoint();
    }
    // ä»interceptoré›†åˆä¸­è·å–ä¸€ä¸ªinterceptor
    Object interceptorOrInterceptionAdvice =
            this.interceptorsAndDynamicMethodMatchers.get(++this.currentInterceptorIndex);
    // è°ƒç”¨è¿™ä¸ªinterceptor.invokeæ–¹æ³•ï¼Œå¼€å§‹èµ°é“¾äº†
    return ((MethodInterceptor) interceptorOrInterceptionAdvice).invoke(this);
}
MethodInterceptorç±»
public interface MethodInterceptor extends Interceptor {
    
    Object invoke(MethodInvocation invocation) throws Throwable;
}

MethodInterceptorå®ç°ç±»
public Object invoke(MethodInvocation mi) throws Throwable {
    // åˆè°ƒå›MethodInvocation.proceed()æ–¹æ³•
    return mi.proceed();
}
----

å¯¹æˆ‘ä»¬äº‹åŠ¡ä»£ç†è€Œè¨€ï¼Œè¿™ä¸ªé“¾ä¸Šçš„interceptorå°±æ˜¯TransactionInterceptorï¼Œç¨‹åºè¿›å…¥TransactionInterceptor.invoke(this)ï¼Œå¯ä»¥çœ‹åˆ°è¿™ä¸ªæ–¹æ³•çš„å‚æ•°æ˜¯thisï¼Œ *ä¸€èˆ¬çš„é“¾å¼è°ƒç”¨æ¨¡å‹éƒ½ä¼šä¼ thisä½œä¸ºå‚æ•°ï¼Œæˆ‘ä»¬åº”è¯¥å­¦ä¼šè¿™ç§é«˜çº§æ“ä½œ*

ä»è¿™ä¸ªæ–¹æ³•æ‰å¼€å§‹è¿›è¡Œspring transactionäº‹åŠ¡æœ‰å…³çš„æ“ä½œï¼Œçœ‹ä¸‹å†…éƒ¨

----
public Object invoke(final MethodInvocation invocation) throws Throwable {
	Class<?> targetClass = (invocation.getThis() != null ? AopUtils.getTargetClass(invocation.getThis()) : null);

	// Adapt to TransactionAspectSupport's invokeWithinTransaction...
	return invokeWithinTransaction(invocation.getMethod(), targetClass, new InvocationCallback() {
		@Override
		public Object proceedWithInvocation() throws Throwable {
			return invocation.proceed();
		}
	});
}
----

invokeWithinTransactionæ–¹æ³•é€»è¾‘ä¸ºå¼€å§‹æ“ä½œTransactionäº‹åŠ¡ç›¸å…³çš„æ“ä½œï¼Œæ‰€ä»¥è¿™ä¸ªæ–¹æ³•å°±å¾ˆé‡è¦äº†ï¼ŒåŒæ—¶æä¾›ä¸€ä¸ªå›è°ƒæ“ä½œï¼šinvocation.proceed()ä»¥è¾¾åˆ°é“¾å¼è°ƒç”¨ã€‚


== äº‹åŠ¡å…¥å£ç‚¹
ä»invokeWithinTransactionæ–¹æ³•çš„ä»£ç æˆ‘ä»¬å¯ä»¥çœ‹åˆ°è¿™æ—¶å€™å¼€å§‹è¿ç”¨äº‹åŠ¡é€»è¾‘ï¼Œäº‹åŠ¡åŒ…è£¹ç€æ–¹æ³•çš„è°ƒç”¨ã€‚ *å¯ä»¥è¯´è¿™é‡Œæ˜¯äº‹åŠ¡çš„æ ¸å¿ƒå’Œå…¥å£*ã€‚çœ‹å…¶ä»£ç 

----
protected Object invokeWithinTransaction(Method method, Class<?> targetClass, final InvocationCallback invocation)
		throws Throwable {

	// If the transaction attribute is null, the method is non-transactional.
	final TransactionAttribute txAttr = getTransactionAttributeSource().getTransactionAttribute(method, targetClass); (1)
	final PlatformTransactionManager tm = determineTransactionManager(txAttr); (2)
	final String joinpointIdentification = methodIdentification(method, targetClass, txAttr); (3)

	if (txAttr == null || !(tm instanceof CallbackPreferringPlatformTransactionManager)) {
		// Standard transaction demarcation with getTransaction and commit/rollback calls.
	    // è·å–äº‹åŠ¡ä¿¡æ¯ï¼ŒåŒ…å«è¿™äº›å±æ€§ï¼šäº‹åŠ¡ç®¡ç†å™¨ï¼šransactionManager;äº‹åŠ¡å±æ€§ï¼štransactionAttribute; äº‹åŠ¡çŠ¶æ€ï¼štransactionStatus;è€äº‹åŠ¡ï¼šoldTransactionInfo;
		TransactionInfo txInfo = createTransactionIfNecessary(tm, txAttr, joinpointIdentification); (4)
		Object retVal = null;
		try {
			// This is an around advice: Invoke the next interceptor in the chain.
			// This will normally result in a target object being invoked.
			retVal = invocation.proceedWithInvocation(); (5)
		}
		catch (Throwable ex) {
			completeTransactionAfterThrowing(txInfo, ex); (6)
			throw ex;
		}
		finally {
			cleanupTransactionInfo(txInfo);
		}  
		commitTransactionAfterReturning(txInfo); (7)
		return retVal;
	}else{
		Â·Â·Â·Â·Â·Â·
	}
}
----

ä»ä»£ç æˆ‘ä»¬çŸ¥é“ï¼Œæ•´ä¸ªæ–¹æ³•çš„æ ¸å¿ƒé€»è¾‘å’Œæˆ‘ä»¬å¹³æ—¶å¯¹äº‹åŠ¡çš„ç†è§£ä¸€æ ·ï¼Œ
åˆ†ä¸ºä¸‰æ­¥ï¼š

1. è°ƒæ–¹æ³•å‰å¼€å§‹äº‹åŠ¡[å³ä»£ç (4)]
2. å¼€å§‹è°ƒç”¨æ–¹æ³•[å³ä»£ç (5)]
3. æ–¹æ³•æŠ¥é”™å°±å›æ»š[å³ä»£ç (6)]ï¼Œæ­£å¸¸ç»“æŸæäº¤äº‹åŠ¡[å³ä»£ç (7)]

åªæ˜¯åœ¨å¼€å§‹äº‹åŠ¡å‰æˆ‘ä»¬è¦è·å–åˆ°äº‹åŠ¡å±æ€§(TransactionAttribute)[å³ä»£ç (1)]å’Œäº‹åŠ¡ç®¡ç†å™¨(PlatformTransactionManager)[å³ä»£ç (2)]ã€‚æ‰€ä»¥é¦–å…ˆæ˜¯ä»TransactionAttributeSource(å…¶å®æ˜¯AnnotationTransactionAttributeSource)è·å–TransactionAttributeï¼Œè¿™ä¸ªå°±æ˜¯ç¨‹åºåˆå§‹åŒ–æ—¶è§£æUserServiceImplæ–¹æ³•æ—¶æ¯ä¸ªæ–¹æ³•ç”Ÿæˆçš„TransactionAttributeï¼Œç°åœ¨åªæ˜¯ä»ç¼“å­˜ä¸­å–å‡ºæ¥ã€‚æ¥ç€è·å–TransactionManagerï¼Œå…¶å®é€šè¿‡ `defaultTransactionManager = this.beanFactory.getBean(PlatformTransactionManager.class);` ï¼Œå³beanFactoryå®¹å™¨è·å–çš„ã€‚æˆ‘ä»¬ä½¿ç”¨çš„æ˜¯é»˜è®¤çš„PlatformTransactionManagerï¼Œæ‰€ä»¥è·å–åˆ°çš„æ˜¯DataSourcePlatformTransactionManagerã€‚

ä¸‹é¢æˆ‘ä»¬çœ‹ç¬¬ä¸€æ­¥ï¼šè·å–äº‹åŠ¡ã€‚è·å–äº‹åŠ¡æ˜¯æ ¹æ®äº‹åŠ¡ç®¡ç†å™¨ï¼Œäº‹åŠ¡å±æ€§ï¼Œæ–¹æ³•å…¨é™å®šåï¼Œçœ‹ä¸‹createTransactionIfNecessaryå†…éƒ¨é€»è¾‘

----
protected TransactionInfo createTransactionIfNecessary(
			PlatformTransactionManager tm, TransactionAttribute txAttr, final String joinpointIdentification) {

	// If no name specified, apply method identification as transaction name.
	if (txAttr != null && txAttr.getName() == null) {
		txAttr = new DelegatingTransactionAttribute(txAttr) {
			@Override
			public String getName() {
				return joinpointIdentification;
			}
		};
	}
    // åˆ›å»ºäº‹åŠ¡çŠ¶æ€å¯¹è±¡
	TransactionStatus status = tm.getTransaction(txAttr);		
	// å‡†å¤‡äº‹åŠ¡ä¿¡æ¯å¯¹è±¡ï¼Œå¹¶æŠŠäº‹åŠ¡ä¿¡æ¯å¯¹è±¡ç»‘å®šåˆ°å½“å‰çº¿ç¨‹ä¸Š 
	return prepareTransactionInfo(tm, txAttr, joinpointIdentification, status);
}
----

æ–¹æ³•ä¸­é€šè¿‡äº‹åŠ¡ç®¡ç†å™¨å’Œäº‹åŠ¡å±æ€§è·å–äº‹åŠ¡çŠ¶æ€ï¼Œæ‰€è°“çš„äº‹åŠ¡çŠ¶æ€ä¿å­˜äº†ä¸€äº›å±æ€§ï¼Œè¿™äº›å±æ€§å€¼å¯¼å‘äº†äº‹åŠ¡çš„ç‰¹æ€§ã€‚æˆ‘ä»¬è¯¦ç»†è¯´ä¸‹

----
DefaultTransactionStatus

	private final Object transaction;

	private final boolean newTransaction;

	private final boolean newSynchronization;

	private final boolean readOnly;

	private final Object suspendedResources;

----

1. Object transactionè¡¨ç¤ºäº‹åŠ¡å¯¹è±¡ï¼Œå®é™…æ˜¯DataSourceTransactionObjectï¼Œæ‹¥æœ‰ConnectionHolderã€previousIsolationLevelç­‰å±æ€§ï¼Œ *äº‹åŠ¡å®ç°çš„æœ¬è´¨æ˜¯å¤šä¸ªæ•°æ®åº“çš„æ“ä½œä½¿ç”¨é€šè¿‡è¿æ¥ï¼šConnection* ã€‚ConnectionHolderåŒ…è£…äº†Connectionå¯¹è±¡ï¼ŒTransactionManageré€šè¿‡ä¸€ä¸ªThreadLocalå±æ€§ä»¥datasourceä¸ºkey,ConnectionHolderä¸ºvalueçš„æ–¹å¼æŒæœ‰ConnectionHolderï¼Œ

2. newTransactionäº‹åŠ¡æœ‰ä¼ æ’­ç‰¹æ€§ï¼Œå¦‚æœæ˜¯åµŒå¥—äº‹åŠ¡ï¼Œé‚£ä¹ˆç¬¬ä¸€ä¸ªäº‹åŠ¡å°±æ˜¯æ–°çš„(newTransaction=true)ï¼ŒåµŒå¥—å†…çš„äº‹åŠ¡å°±æ˜¯æ—§çš„(newTransaction=false)

3. newSynchronization ç”¨äºåœ¨äº‹åŠ¡commit/completeå‰åè¿›è¡Œå›è°ƒæ“ä½œçš„æ ‡è¯†

4. suspendedResources ç¿»è¯‘ä¸­æ–‡å°±æ˜¯æš‚åœèµ„æºï¼Œç”¨äºå½“æœ‰ä¸¤ä¸ªä»¥ä¸Šäº‹åŠ¡åœºæ™¯çš„æ—¶å€™ï¼Œä¿å­˜ä¸Šä¸€ä¸ªäº‹åŠ¡ä¿¡æ¯ï¼Œä»è€Œå½“å½“å‰äº‹åŠ¡å®Œæˆåå¯ä»¥å›åˆ°ä¸Šä¸€ä¸ªäº‹åŠ¡

TransactionStatuså±æ€§æ„ä¹‰è¯·å‚è€ƒï¼š https://www.cnblogs.com/chihirotan/p/6760317.html[äº‹åŠ¡çš„çŠ¶æ€TransactionStatus] å’Œ https://blue2048.iteye.com/blog/2180921[springäº‹åŠ¡æ·±å…¥å‰–æ - ä¸€äº›é‡è¦çŠ¶æ€å¯¹è±¡çš„åˆ†æ]

æˆ‘ä»¬ç°åœ¨å›åˆ°ç¨‹åºä¸­ï¼Œçœ‹ä¸‹äº‹åŠ¡æ˜¯æ€æ ·è·å–çš„ï¼Œäº‹åŠ¡çŠ¶æ€å±æ€§å€¼æ˜¯æ€æ ·èµ‹å€¼å’Œè·å–çš„ï¼Œäº‹åŠ¡çŠ¶æ€æ˜¯æ ¹æ®äº‹åŠ¡ç®¡ç†å™¨å’Œäº‹åŠ¡å±æ€§è·å–çš„ã€‚çœ‹å…¶tm.getTransactionå†…éƒ¨ä»£ç 

----
public final TransactionStatus getTransaction(TransactionDefinition definition) throws TransactionException {
	// springé»˜è®¤ä½¿ç”¨spring jdbcçš„äº‹åŠ¡ï¼Œæ‰€ä»¥è¿™é‡Œä¼šåˆ›å»ºDataSourceTransactionObjectå¯¹è±¡ï¼Œå¹¶ä»äº‹åŠ¡ç®¡ç†å™¨TransactionManageræ ¹æ®dataSourceä»ThreadLocalè·å–ConnectioinHolderèµ‹å€¼ç»™DataSourceTransactionObjectå¯¹è±¡çš„å±æ€§
	Object transaction = doGetTransaction();(a)

	if (definition == null) {
		definition = new DefaultTransactionDefinition();
	}

	// åˆ¤æ–­æ˜¯å¦å·²å­˜åœ¨äº‹åŠ¡ï¼šåˆ¤æ–­ä¾æ®å°±æ˜¯DataSourceTransactionObject.connectionHolderå€¼æ˜¯å¦ä¸ºnull
	if (isExistingTransaction(transaction)) {
		// Existing transaction found -> check propagation behavior to find out how to behave.
		// å¦‚æœå­˜åœ¨äº‹åŠ¡ï¼Œèµ°å·²å­˜åœ¨äº‹åŠ¡çš„é€»è¾‘ï¼Œä½¿ç”¨åŒä¸Šä¸€ä¸ªäº‹åŠ¡å»å¤„ç†æ“ä½œ
		return handleExistingTransaction(definition, transaction, debugEnabled);(b)
	}
	
	// ç¨‹åºèµ°åˆ°è¿™é‡Œï¼Œè¯´æ˜æ²¡æœ‰å·²å­˜åœ¨çš„äº‹åŠ¡
	if (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_REQUIRED ||
			definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_REQUIRES_NEW ||
			definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NESTED) {
		// æ­¤æ–¹æ³•ä¸ºæš‚åœäº‹åŠ¡ï¼Œç”±äºæ²¡æœ‰å·²å­˜åœ¨çš„äº‹åŠ¡ï¼Œæ‰€ä»¥è¿™é‡Œä¼ çš„æ˜¯nullï¼Œè¡¨ç¤ºæ— éœ€æš‚åœäº‹åŠ¡
		SuspendedResourcesHolder suspendedResources = suspend(null);(c)
		try {
			boolean newSynchronization = (getTransactionSynchronization() != SYNCHRONIZATION_NEVER);
			// åˆ›å»ºäº‹åŠ¡çŠ¶æ€å¯¹è±¡
			DefaultTransactionStatus status = newTransactionStatus(
					definition, transaction, true, newSynchronization, debugEnabled, suspendedResources);
			// ç»™transactionå±æ€§èµ‹å€¼ï¼ŒåŒ…æ‹¬ConnectionHolder(Connectionçš„AutoCommitè®¾ç½®ä¸ºfalse)ï¼ŒpreviousIsolationLevel
			// åŒæ—¶å°†transaction.ConnectionHolderå’ŒDataSoureceç»‘å®šåˆ°äº‹åŠ¡ç®¡ç†å™¨TransactionSynchronizationManagerçš„ThreadLocalå±æ€§ä¸Š
			doBegin(transaction, definition);(d)
			// TransactionStatus.newSynchronization==true,å®ä¾‹åŒ–transaction synchronizationå¹¶ç»‘å®šåˆ°TransactionSynchronizationManager
			prepareSynchronization(status, definition);(e)
			return status;
		}
		catch (RuntimeException ex) {
			resume(null, suspendedResources);
			throw ex;
		}
	}else {
		// Create "empty" transaction: no actual transaction, but potentially synchronization.
		boolean newSynchronization = (getTransactionSynchronization() == SYNCHRONIZATION_ALWAYS);
		return prepareTransactionStatus(definition, null, true, newSynchronization, debugEnabled, null);
	}
}
----

ä»è¿™ä¸ªæ–¹æ³•çš„é€»è¾‘å¯ä»¥çœ‹åˆ°ï¼Œå…ˆè·å–äº‹åŠ¡å¯¹è±¡(æ­¤æ—¶å¾ˆå¤šå±æ€§è¿˜æ²¡æœ‰èµ‹å€¼)ï¼Œç„¶ååˆ¤æ–­è¿™ä¸ªäº‹åŠ¡æ˜¯å¦æ˜¯å·²å­˜åœ¨çš„ï¼Œæ˜¯èµ°å·²å­˜åœ¨çš„é€»è¾‘ï¼›ä¸æ˜¯çš„è¯ï¼Œä½¿ç”¨è¿™ä¸ªäº‹åŠ¡å¯¹è±¡åˆ›å»ºä¸€ä¸ªæ–°çš„äº‹åŠ¡çŠ¶æ€å¯¹è±¡TransactionStatus,ç„¶åæ ¹æ®TransactionDefinition(æŒæœ‰éš”ç¦»çº§åˆ«å’Œä¼ æ’­ç‰¹æ€§å€¼)çš„ä¸ªå±æ€§å€¼ç»™äº‹åŠ¡å¯¹è±¡DataSourceTransactionObjectçš„å„ä¸ªå±æ€§èµ‹å€¼ã€‚åŒæ—¶å°†ConnectionHolderå’ŒDataSoureceå’Œç»‘å®šåˆ°TransactionStatuså’ŒTransactionSynchronizationManagerå¯¹è±¡ä¸Šã€‚æ¥ç€æ ¹æ®äº‹åŠ¡çŠ¶æ€å’Œäº‹åŠ¡å®šä¹‰å®ä¾‹åŒ–transaction synchronizationå¹¶èµ‹å€¼ç»™äº‹åŠ¡ç®¡ç†å™¨ã€‚

è¿™æ ·äº‹åŠ¡çŠ¶æ€å°±ç¡®å®šäº†ï¼Œå³äº‹åŠ¡çŠ¶æ€TransactionStatuså¯¹è±¡åˆ›å»ºå¥½äº†ã€‚ç„¶åæ ¹æ®åˆ›å»ºå¥½çš„äº‹åŠ¡å¯¹è±¡å’Œäº‹åŠ¡å±æ€§åˆ›å»ºäº‹åŠ¡ä¿¡æ¯å¯¹è±¡TransactionInfoã€‚è¿™ä¸ªå¯¹è±¡å›Šæ‹¬äº†äº‹åŠ¡ç›¸å…³çš„æ‰€æœ‰ä¿¡æ¯ï¼ŒåŒ…æ‹¬äº‹åŠ¡ç®¡ç†å™¨ï¼Œäº‹åŠ¡å±æ€§ï¼Œäº‹åŠ¡çŠ¶æ€ï¼Œè€äº‹åŠ¡ã€‚å±æ€§å¦‚ä¸‹ï¼š

----
TransactionInfo class
	private final PlatformTransactionManager transactionManager;

	private final TransactionAttribute transactionAttribute;

	private final String joinpointIdentification;

	private TransactionStatus transactionStatus;

	private TransactionInfo oldTransactionInfo;

----

åˆ°è¿™ï¼Œäº‹åŠ¡ä¿¡æ¯å°±éƒ½è®¾ç½®å®Œäº†ï¼Œç¬¬ä¸€æ­¥ä¹Ÿæ‰§è¡Œå®Œäº†ã€‚ä¸‹é¢èµ°ç¬¬äºŒæ­¥ï¼Œè°ƒç”¨æˆ‘ä»¬å®é™…çš„ä¸šåŠ¡æ–¹æ³•ï¼Œå³userService.updateSchoolNameæ–¹æ³•ã€‚è¿™é‡Œå°±ä¸å±•å¼€äº†ã€‚

ä¸‹é¢å¦‚æœä¸šåŠ¡æ–¹æ³•æ‰§è¡Œæ­£å¸¸ç»“æœï¼Œå°±æäº¤äº‹åŠ¡ï¼Œå³commitTransactionAfterReturningæ–¹æ³•ï¼›å¦‚æœå‡ºç°å¼‚å¸¸ï¼Œåˆ™æ‰§è¡ŒcompleteTransactionAfterThrowingæ–¹æ³•é€»è¾‘ã€‚ä¸¤ç§æƒ…å†µèµ°å®Œçš„åï¼Œéƒ½ä¼šè°ƒç”¨cleanupTransactionInfoæ–¹æ³•æ¸…é™¤å¯¹è±¡ï¼Œé‡Šæ”¾å†…å­˜ã€‚
ä¸‹é¢çœ‹ç¬¬ä¸€ç§æƒ…å†µï¼Œæ­£å¸¸commitæäº¤çš„é€»è¾‘ï¼Œå³commitTransactionAfterReturningæ–¹æ³•ï¼Œæˆ‘ä»¬çœ‹ä¸‹è¿™ä¸ªæ–¹æ³•çš„å†…éƒ¨é€»è¾‘

----
protected void commitTransactionAfterReturning(TransactionInfo txInfo) {
	txInfo.getTransactionManager().commit(txInfo.getTransactionStatus());
}
AbstractPlatformTransactoinManager
public final void commit(TransactionStatus status) throws TransactionException {
	Â·Â·Â·Â·Â·Â·
	processCommit(defStatus);
}
private void processCommit(DefaultTransactionStatus status) throws TransactionException {
	try {
		boolean beforeCompletionInvoked = false;
		try {
			prepareForCommit(status);
			// æäº¤å‰å›è°ƒï¼Œè¿™æ—¶äº‹åŠ¡çŠ¶æ€å¯¹è±¡çš„newSynchronizationå¼€å§‹èµ·ä½œç”¨ï¼ŒTransaction synchronizationåšäº›äº‹æƒ…
			triggerBeforeCommit(status);
			triggerBeforeCompletion(status);
			beforeCompletionInvoked = true;
			boolean globalRollbackOnly = false;
			// NewTransactionæ˜¯å¦æ˜¯æ–°äº‹åŠ¡ï¼Œåªæœ‰ä¸€ä¸ªäº‹åŠ¡é‚£å°±æ˜¯æ–°äº‹åŠ¡ï¼ŒåµŒå¥—äº‹åŠ¡çš„æ—¶å€™ï¼Œåªæ˜¯æœ€å¤–å±‚çš„äº‹åŠ¡æ˜¯æ–°äº‹åŠ¡(å³NewTransaction=true)
			if (status.isNewTransaction() || isFailEarlyOnGlobalRollbackOnly()) {
				globalRollbackOnly = status.isGlobalRollbackOnly();
			}
			if (status.hasSavepoint()) {
				status.releaseHeldSavepoint();
			}
			// äº‹åŠ¡éƒ½æ‰§è¡Œå®Œæ‰åšäº‹åŠ¡æäº¤doCommitæ“ä½œ
			else if (status.isNewTransaction()) {
				doCommit(status);
			}
		catch (UnexpectedRollbackException ex) {
			// can only be caused by doCommit
			triggerAfterCompletion(status, TransactionSynchronization.STATUS_ROLLED_BACK);
			throw ex;
		}
		catch (TransactionException ex) {
			// can only be caused by doCommit
			if (isRollbackOnCommitFailure()) {
				doRollbackOnCommitException(status, ex);
			}
			else {
				triggerAfterCompletion(status, TransactionSynchronization.STATUS_UNKNOWN);
			}
			throw ex;
		}
		catch (RuntimeException ex) {
			if (!beforeCompletionInvoked) {
				triggerBeforeCompletion(status);
			}
			doRollbackOnCommitException(status, ex);
			throw ex;
		}
		catch (Error err) {
			if (!beforeCompletionInvoked) {
				triggerBeforeCompletion(status);
			}
			doRollbackOnCommitException(status, err);
			throw err;
		}

		// Trigger afterCommit callbacks, with an exception thrown there
		// propagated to callers but the transaction still considered as committed.
		try {
			triggerAfterCommit(status);
		}
		finally {
			triggerAfterCompletion(status, TransactionSynchronization.STATUS_COMMITTED);
		}

	}
	finally {
		cleanupAfterCompletion(status);
	}
}
----
å¯¹äºprocessCommitæ–¹æ³•ï¼Œæ ¸å¿ƒæ˜¯doCommitæ“ä½œï¼Œåœ¨è¿™å‰åæ ¹æ®æ‰§è¡ŒnewSynchronizationå’ŒNewTransactionè§¦å‘å›è°ƒæ“ä½œ

æ¥ç€çœ‹ç¬¬äºŒç§æƒ…å†µï¼Œå³å‡ºç°å¼‚å¸¸æ‰§è¡ŒcompleteTransactionAfterThrowingæ–¹æ³•é€»è¾‘ã€‚çœ‹å…¶ä»£ç å®ç°

----
protected void completeTransactionAfterThrowing(TransactionInfo txInfo, Throwable ex) {
	if (txInfo != null && txInfo.hasTransaction()) {
		// åˆ¤æ–­å¯¹è¿™ä¸ªå¼‚å¸¸æ˜¯å¦å›æ»šï¼Œè¿™ä¸ªé€»è¾‘å¾ˆé‡è¦äº†
		if (txInfo.transactionAttribute.rollbackOn(ex)) {
			try {
				// æ‰§è¡Œå›æ»šæ“ä½œï¼Œæœ€ç»ˆè°ƒç”¨Connection.rollback()æ–¹æ³•
				txInfo.getTransactionManager().rollback(txInfo.getTransactionStatus());
			}catch (Error err) {
				throw err;
			}
		}
		else {
			// ä¸å›æ»šäº†ï¼Œç›´æ¥æäº¤commit
			try {
				txInfo.getTransactionManager().commit(txInfo.getTransactionStatus());
			}catch (Error err) {
				logger.error("Application exception overridden by commit error", ex);
				throw err;
			}
		}
	}
}
----

æˆ‘ä»¬å¹³æ—¶å¯èƒ½ä¼šå¬åˆ°å…¶ä»–äººè¯´springäº‹åŠ¡é»˜è®¤åªæœ‰è¿è¡Œæ—¶å·²æˆRuntimeExceptionæ‰å›æ»šï¼Œåƒéè¿è¡Œæ—¶å¼‚å¸¸ä¸å›æ»šï¼Œæˆ‘çœ‹ä¸‹è¿™é‡Œå›æ»šçš„é€»è¾‘ï¼Œä»è€ŒçŸ¥é“è¿™ä¸ªç°è±¡çš„æœ¬è´¨åŸå› ï¼Œçœ‹ä»£ç 

----
RuleBasedTransactionAttribute ç±»
public boolean rollbackOn(Throwable ex) {
	RollbackRuleAttribute winner = null;
	int deepest = Integer.MAX_VALUE;

    // åªæœ‰æˆ‘ä»¬ä¸šåŠ¡æ–¹æ³•ä¸­é…ç½®çš„@Transactional.rollbackforçš„å€¼ï¼ŒrollbackRulesæ‰åªæœ‰è¿™ä¸ªå€¼ï¼Œå¦åˆ™rollbackRulesä¸ºç©º
	if (this.rollbackRules != null) {
		for (RollbackRuleAttribute rule : this.rollbackRules) {
			int depth = rule.getDepth(ex);
			if (depth >= 0 && depth < deepest) {
				deepest = depth;
				winner = rule;
			}
		}
	}
    // æˆ‘ä»¬æ²¡æœ‰é…ç½®ä¸šåŠ¡æ–¹æ³•ä¸­çš„@Transactional.rollbackforçš„å€¼æ—¶ï¼Œèµ°è¿™é‡Œçš„é€»è¾‘ï¼Œå³springé»˜è®¤çš„å›æ»šé€»è¾‘
	if (winner == null) {
		return super.rollbackOn(ex);
	}

	return !(winner instanceof NoRollbackRuleAttribute);
}
----

è¿™ä¸ªæ–¹æ³•çš„è¿”å›å€¼å†³å®šäº†äº‹åŠ¡å›æ»šï¼Œè€Œè¿”å›å€¼ç”±ä¸¤ç§æƒ…å†µå†³å®š
1. æƒ…å†µä¸€ï¼Œä¸šåŠ¡æ–¹æ³•ä¸­é…ç½®äº†@Transactional.rollbackforçš„å€¼
ä»è€ŒList<RollbackRuleAttribute>ç±»å‹çš„å±æ€§rollbackRulesæœ‰å€¼ï¼Œæ‰€ä»¥RollbackRuleAttribute.exceptionNameå±æ€§æœ‰å€¼ï¼Œå€¼ä¸ºæˆ‘ä»¬åœ¨ä¸šåŠ¡æ–¹æ³•ä¸Šé…ç½®çš„@Transactional.rollbackforçš„exceptionå€¼ï¼Œå¯¹æ¯”å¦‚ä¸‹å›¾ï¼Œæ›´æ¸…æ™°

image::https://raw.githubusercontent.com/yaoyuanyy/MarkdownPhotos/master/img/20201129091020.png[20201129091020]


image::https://raw.githubusercontent.com/yaoyuanyy/MarkdownPhotos/master/img/20201129091044.png[20201129091044]

æˆ‘ä»¬çœ‹ä¸‹æ•´ä¸ªRuleBasedTransactionAttribute.rollbackOnæ–¹æ³•çš„é€»è¾‘ä¸ºæ ¹æ®RollbackRuleAttribute.getDepth(ex)æ–¹æ³•è¿”å›çš„intå€¼å†³å®šwinnerå±æ€§çš„å€¼ï¼Œåˆ¤æ–­winnerçš„ç±»å‹æ˜¯å¦ä¸ºNoRollbackRuleAttributeï¼Œä»è€Œå†³å®šæ–¹æ³•çš„è¿”å›å€¼true or falseï¼Œè¿›è€Œå†³å®šæ˜¯å¦æ‰§è¡Œå›æ»šæ“ä½œã€‚é‡ç‚¹å°±åœ¨RollbackRuleAttribute.getDepth(ex)ã€‚æˆ‘ä»¬çœ‹ä¸‹è¿™ä¸ªæ–¹æ³•çš„é€»è¾‘

----
RollbackRuleAttribute ç±»
private int getDepth(Class<?> exceptionClass, int depth) {
	if (exceptionClass.getName().contains(this.exceptionName)) {
		return depth;
	}
	if (exceptionClass == Throwable.class) {
		return -1;
	}
	return getDepth(exceptionClass.getSuperclass(), depth + 1);
}
----

è¿™æ˜¯ä¸€ä¸ªé€’å½’æ–¹æ³•ï¼Œé¦–å…ˆæ¯”è¾ƒæˆ‘ä»¬é…ç½®çš„ExceptionNameå’Œç¨‹åºäº§ç”Ÿçš„å¼‚å¸¸nameï¼Œå¦‚æœç›´æ¥åŒ…å«ï¼Œè¿”å›é»˜è®¤çš„depthå€¼(é»˜è®¤ä¸º0ï¼Œè¡¨ç¤ºç²¾å‡†åŒ¹é…)ï¼Œå¦‚æœäº§ç”Ÿçš„å¼‚å¸¸æ—¶Throwableï¼Œè¡¨ç¤ºä¸åŒ¹é…ï¼Œä¸¤ç§æƒ…å†µéƒ½ä¸ç¬¦åˆï¼Œè¿›å…¥é€’å½’æ“ä½œï¼Œæ‹¿åˆ°ç¨‹åºäº§ç”Ÿå¼‚å¸¸ç±»çš„çˆ¶ç±»è¿›è¡Œä»¥ä¸Šé€»è¾‘çš„åˆ¤æ–­ã€‚

1. æƒ…å†µäºŒ æˆ‘ä»¬æ²¡æœ‰é…ç½®ä¸šåŠ¡æ–¹æ³•ä¸­çš„@Transactional.rollbackforçš„å€¼æ—¶ï¼Œæƒ…å½¢å¦‚ä¸‹å›¾ã€‚

image::https://raw.githubusercontent.com/yaoyuanyy/MarkdownPhotos/master/img/20201129091218.png[20201129091218]

æ²¡æœ‰é…ç½®@Transactional.rollbackforçš„å€¼ï¼Œwinner == nullï¼Œæ‰€ä»¥ç¨‹åºèµ°super.rollbackOn(ex)ï¼Œå³springäº‹åŠ¡é»˜è®¤çš„å›æ»šé€»è¾‘ã€‚çœ‹ä¸‹è¿™ä¸ªä»£ç é€»è¾‘

----
DefaultTransactionAttribute ç±»
public boolean rollbackOn(Throwable ex) {
	return (ex instanceof RuntimeException || ex instanceof Error);
}
----

æ–¹æ³•é€»è¾‘ä¸ºæ˜¯RuntimeExceptionæ‰å›æ»šã€‚

åˆ°è¿™é‡Œæˆ‘ä»¬å°±æ˜ç™½äº†ï¼Œ *ä¸ºä»€ä¹ˆè¯´springäº‹åŠ¡é»˜è®¤åªæœ‰è¿è¡Œæ—¶å¼‚å¸¸RuntimeExceptionæ‰å›æ»šï¼Œåƒéè¿è¡Œæ—¶å¼‚å¸¸ä¸å›æ»šï¼Œæ‰€ä»¥å¹³æ—¶åœ¨å®é™…çš„å¼€å‘è¿‡ç¨‹ä¸­ï¼Œå†™äº‹åŠ¡æ—¶è®°å¾—é…ç½®@Transactional.rollbackforï¼Œè¿™æ ·ä»»ä½•å¼‚å¸¸éƒ½ä¼šæ‰§è¡Œå›æ»šæ“ä½œäº†*



== é—®é¢˜å›ç­”
é—®é¢˜ï¼š

----
1. å¹³æ—¶æ€»æ˜¯springé»˜è®¤çš„äº‹åŠ¡åªæœ‰è¿è¡Œæ—¶å¼‚å¸¸æ‰å›æ»šï¼Œä¸ºä»€ä¹ˆ
2. äº‹åŠ¡çš„savepointæ˜¯ä»€ä¹ˆ
3. å¦‚ä½•åšåˆ°å¤šä¸ªæ•°æ®æ“ä½œçš„äº‹åŠ¡æäº¤å’Œå›æ»šçš„
----
å›ç­”ï¼š

----
1. RuleBasedTransactionAttribute.rollbackOn(Throwable ex)æ–¹æ³•è§£é‡Šäº†è¿™ä¸ªé—®é¢˜çš„æœ¬è´¨ï¼Œæ–‡ä¸­ä¹Ÿæœ‰è¯¦ç»†çš„åˆ†æå’Œé˜è¿°
2. äº‹åŠ¡çš„savepointæ˜¯ä»€ä¹ˆ TODO
3. äº‹åŠ¡å…·æœ‰ä¼ æ’­ç‰¹æ€§ï¼ŒåŒä¸€ä¸ªäº‹åŠ¡å¯¹æ•°æ®åº“çš„è¿æ¥Connectionçš„æ˜¯ç›¸åŒçš„ï¼Œæœ¬è´¨çš„é€šè¿‡Connection.commitå’ŒConnection.rollbackå®ç°çš„
----


== spring transaction å…³é”®è¯
0.AbstractPlatformTransactionManager

springæ ‡å‡†äº‹åŠ¡å·¥ä½œæµçš„åŸºç¡€ç±»ï¼Œä½œä¸ºå…·ä½“äº‹åŠ¡ç®¡ç†å™¨çš„åŸºç¡€ã€‚è¿™ä¸ªåŸºç¡€ç±»æä¾›ä»¥ä¸‹çš„å·¥ä½œæµçš„å¤„ç†ï¼š

. åˆ¤æ–­æ˜¯å¦æœ‰ä¸€ä¸ªå­˜åœ¨çš„äº‹åŠ¡
. åº”ç”¨åˆé€‚çš„ä¼ æ’­è¡Œä¸º
. æš‚åœsuspendå’Œé‡æ–°ä½¿ç”¨resumeäº‹åŠ¡if necessary
. åœ¨commitæäº¤æ˜¯æ£€æŸ¥å›æ»šrollback-onlyæ ‡è¯†
. åœ¨å›æ»šrollbackæ—¶åº”ç”¨åˆé€‚çš„ä¿®æ”¹åŠ¨ä½œ actual rollback or setting rollback-only
. triggers registered synchronization callbacks (if transaction synchronization is active).
å­ç±»å¿…é¡»ä¸ºäº‹åŠ¡ç‰¹å®šçŠ¶æ€å®ç°ç‰¹å®šçš„template methodsï¼Œåƒ: begin, suspend, resume, commit, rollback. ä»–ä»¬éƒ½æ˜¯å¾ˆé‡è¦çš„ï¼Œå¿…é¡»è¢«å…·ä½“çš„å®ç°ç±»å®ç°å’Œæä¾›
äº‹åŠ¡åŒæ­¥(Transaction synchronization)æ˜¯å½“äº‹åŠ¡å®Œæˆæ—¶æä¾›å›è°ƒçš„ä¸€èˆ¬æœºåˆ¶ã€‚è¿™ä¸»è¦æ˜¯è¢«ç”¨äºå†…éƒ¨çš„æ•°æ® the data access support classes for JDBC, Hibernate, JPA

1. ConnectionHolder
æŒæœ‰Connectionï¼Œsavepointå±æ€§,savepointæ˜¯jdbcçš„ç‰¹æ€§ã€‚ConnectionHolderåˆ›å»ºConnectionå¯¹è±¡çš„savepoint

2. TransactionAspectSupport
äº‹åŠ¡åˆ‡é¢çš„åŸºç¡€ç±»(Base class for transactional aspects)ï¼Œæ˜¯TransactionInterceptorçš„çˆ¶ç±»ï¼Œæ‹¥æœ‰transactionInfoHolderå±æ€§ï¼Œä»–çš„æ–¹æ³•invokeWithinTransactionæ˜¯äº‹åŠ¡å’Œä¸šåŠ¡æ–¹æ³•ç»“åˆçš„å…¥å£å¤„ï¼Œäº‹åŠ¡æ“ä½œå‡ ä¹åœ¨è¿™ä¸ªç±»ä¸­å®Œæˆ

3. TransactionDefinition
Spring transactionå±æ€§ç±»ï¼Œå®šä¹‰äº†äº‹åŠ¡ä¼ æ’­ç‰¹æ€§ï¼Œäº‹åŠ¡éš”ç¦»çº§åˆ«ï¼Œå¯è¯»æ€§ï¼Œäº‹åŠ¡åç§°ç­‰å±æ€§

4. TransactionAttribute
TransactionDefinitionçš„å­ç±»ï¼Œæ¯”TransactionDefinitionå¤šçš„éƒ¨åˆ†æ˜¯å¢åŠ äº†rollbackåŠŸèƒ½

5. DataSourceTransactionObject
äº‹åŠ¡æœ¬èº«å¯¹è±¡ã€‚DataSourceçš„äº‹åŠ¡å¯¹è±¡(transaction object)ï¼ŒæŒæœ‰ConnectionHolderç­‰

6. TransactionStatus 

----
DefaultTransactionStatus

	private final Object transaction; äº‹åŠ¡å¯¹è±¡

	private final boolean newTransaction; æ˜¯å¦ä¸ºæ–°äº‹ç‰©ï¼Œäº‹åŠ¡åµŒå¥—å’Œå¤šä¸ªäº‹åŠ¡æ—¶ï¼Œåªæœ‰ç¬¬ä¸€ä¸ªäº‹åŠ¡æ˜¯æ–°äº‹åŠ¡(newTransaction=true)

	private final boolean newSynchronization; æ˜¯å¦ä¸ºæ–°åŒæ­¥, newSynchronization=trueæ—¶è§¦å‘äº‹åŠ¡å›è°ƒ
 
	private Object savepoint; ä¿å­˜ç‚¹ï¼Œç”¨äºåµŒå¥—äº‹åŠ¡æ—¶

	private final Object suspendedResources; æš‚åœçš„èµ„æºï¼šäº‹åŠ¡ï¼Œå½“å¤šä¸ªäº‹åŠ¡æ—¶èµ·ä½œç”¨
----

7.TransactionInfo

----
æ‹¥æœ‰PlatformTransactionManager,TransactionAttribute,TransactionStatus,oldTransactionInfoç­‰å±æ€§
----

è¿™å‡ ä¸ªå¯¹è±¡é—´çš„å…³ç³»é€šè¿‡å›¾çš„æ–¹æ³•

image::https://raw.githubusercontent.com/yaoyuanyy/MarkdownPhotos/master/img/20201129091326.png[20201129091326]

## è°ƒç”¨é“¾å›¾

image::https://raw.githubusercontent.com/yaoyuanyy/MarkdownPhotos/master/img/20201129091348.png[20201129091348]

== æ‰©å±•

1. Transaction Synchronizationå«ä¹‰ (è§¦å‘æäº¤æ“ä½œå›è°ƒçš„)Trigger xxxCommit callbacks.

----
Transaction Synchronization. The Java Transaction API includes a javax.transaction.Synchronization interface, which issues notifications before and after a transaction is completed. ... After the transaction is committed or rolled back, the TransactionManager calls the Synchronization object's afterCompletion() method.
----