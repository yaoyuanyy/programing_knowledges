= ç»†èŠ‚çŸ¥å¤šå°‘ - spring boot aopè¿‡ç¨‹è§£æä¹‹é˜¶æ®µä¸‰ CglibAopProxyæˆ–JdkDynamicAopProxyç”ŸæˆProxyä»£ç†ç±»é˜¶æ®µ
:toc: left
:toc-title: ç›®å½•
:tip-caption: ğŸ’¡
:note-caption: â„¹ï¸
:important-caption: â—
:caution-caption: ğŸ”¥
:warning-caption: âš ï¸
// :tip-caption: :bulb:
// :note-caption: :information_source:
// :important-caption: :heavy_exclamation_mark:	
// :caution-caption: :fire:
// :warning-caption: :warning:
:icons: font

Doc writer yaoyihao1@gmail.com

æ­¤ç¯‡æ˜¯ç»†èŠ‚çŸ¥å¤šå°‘-spring boot aopè¿‡ç¨‹è§£æç³»åˆ—çš„ç¬¬ä¸‰ç¯‡ï¼Œå³ç¬¬ä¸‰é˜¶æ®µ

spring bootçš„aopå®ç°åˆ†ä¸ºä¸‰ä¸ªé˜¶æ®µ

- AnnotationAwareAspectJAutoProxyCreatoråŠ è½½(åˆå§‹åŒ–å’Œå®ä¾‹åŒ–)é˜¶æ®µ
- AnnotationAwareAspectJAutoProxyCreatorä½¿ç”¨post-processåŸºäº@AspectéªŒè¯beanNameæˆ–beanClassæ˜¯å¦å¯ä»¥ç”ŸæˆProxyä»£ç†ç±»é˜¶æ®µ
- CglibAopProxyæˆ–JdkDynamicAopProxyç”ŸæˆProxyä»£ç†ç±»é˜¶æ®µ

ä¸Šä¸¤ä¸ªé˜¶æ®µçš„å†…å®¹å‚è§ï¼š
https://yaoyuanyy.github.io/2019/04/28/%E7%BB%86%E8%8A%82%E6%8A%A0%E5%87%BA%E8%A1%80%20-%20spring%20boot%20aop%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E8%A7%A3%E6%9E%90%E4%B9%8B%E9%98%B6%E6%AE%B5%E4%B8%89/[spring boot aopè¿‡ç¨‹è§£æä¹‹é˜¶æ®µä¸€ï¼šAnnotationAwareAspectJAutoProxyCreatoråŠ è½½(åˆå§‹åŒ–å’Œå®ä¾‹åŒ–)]
https://yaoyuanyy.github.io/2019/04/28/%E7%BB%86%E8%8A%82%E6%8A%A0%E5%87%BA%E8%A1%80%20-%20spring%20boot%20aop%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E8%A7%A3%E6%9E%90%E4%B9%8B%E9%98%B6%E6%AE%B5%E4%B8%89/[spring boot aopè¿‡ç¨‹è§£æä¹‹é˜¶æ®µäºŒï¼šåˆ¤æ–­beanNameæˆ–beanClassæ˜¯å¦ç”ŸæˆProxyä»£ç†ç±»]


è¿™ç¯‡æˆ‘ä»¬è¯´ä¸‹é˜¶æ®µä¸‰ï¼š<B>CglibAopProxyæˆ–JdkDynamicAopProxyç”ŸæˆProxyä»£ç†ç±»é˜¶æ®µ</B>ã€‚

== å¸¦ç€é—®é¢˜å­¦ä¹ 

> å¸¦ç€é—®é¢˜å­¦ä¹ å¾€å¾€èµ·åˆ°æ›´å¥½çš„æ•ˆæœ



é—®é¢˜
----
1. ä»€ä¹ˆæ—¶å€™ä»€ä¹ˆä½ç½®åœ¨çœŸå®å¯¹è±¡æ–¹æ³•å‰ååŠ ä¸Šä»£ç†é€»è¾‘çš„

----

== å‰æ

å®é™…å·¥ä½œä¸­ï¼Œæˆ‘ä»¬éƒ½å†™è¿‡@Aspectçš„ä»£ç å§ã€‚æˆ‘ä»¬è¿™é‡Œå®šä¹‰ä¸€ä¸ªï¼Œä¾¿äºåé¢çŸ¥è¯†ç‚¹é˜è¿°
----
@Aspect
@Component
public class TimeFeeAspect {

    @Pointcut("execution(* com.yy..rest..*(..))")
    public void cut(){}

    @Before("cut()")
    public void doTimeFeeIntercepter(JoinPoint joinPoint) throws Throwable {
        System.out.println("args:" + joinPoint.getArgs());
        System.out.println("target" + joinPoint.getTarget().toString());
    }

}

package com.yy.rest;
@RestController
@RequestMapping("/user")
public class UserController {

    @RequestMapping("/test")
    public String test() {
        return "success";
    }
}
----

åŒä¸Šä¸€ç¯‡ä¸€æ ·ï¼Œæˆ‘ä»¬å®šä¹‰ä¸€ä¸ªAspectç±»ï¼Œç›®çš„æ˜¯å¯¹`com.yy..rest`åŒ…ä¸‹æ‰€æœ‰çš„æ–¹æ³•çš„è®¿é—®éƒ½è¢«åˆ‡é¢åˆ‡å…¥ï¼Œä¹Ÿå°±æ˜¯è¦èµ°`doTimeFeeIntercepter()`æ–¹æ³•ã€‚åŒæ—¶ï¼Œåœ¨com.yy.reståŒ…ä¸‹å®šä¹‰äº†ä¸€ä¸ªç±»ï¼šUserControllerï¼Œå……å½“ç›®æ ‡ç±»ï¼štargetClassï¼Œå£°æ˜äº†ä¸€ä¸ªæ–¹æ³•ï¼štest()ï¼Œä»è€Œåœ¨è®¿é—®è¿™ä¸ªæ–¹æ³•æ—¶ï¼Œä¼šè¢«doTimeFeeIntercepter()æ–¹æ³•åˆ‡å…¥

ä¸‹é¢æˆ‘ä»¬é€šè¿‡debugè¿½è¸ªæºç ï¼Œäº†è§£å®ç°åŸç†ã€‚

== ç”ŸæˆProxyä»£ç†ç±»å…¥å£

ä»ä¸Šä¸€ç¯‡ https://yaoyuanyy.github.io/2019/04/28/%E7%BB%86%E8%8A%82%E6%8A%A0%E5%87%BA%E8%A1%80%20-%20spring%20boot%20aop%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E8%A7%A3%E6%9E%90%E4%B9%8B%E9%98%B6%E6%AE%B5%E4%B8%89[spring boot aopè¿‡ç¨‹è§£æä¹‹é˜¶æ®µäºŒï¼šåˆ¤æ–­beanNameæˆ–beanClassæ˜¯å¦ç”ŸæˆProxyä»£ç†ç±»] æˆ‘ä»¬å¯ä»¥çŸ¥é“ï¼Œå½“åˆ¤æ–­beanNameæˆ–beanClasså¯ä»¥ç”ŸæˆProxyä»£ç†ç±»æ—¶ï¼Œå°±è¿›è¡Œç”Ÿæˆproxyä»£ç†ç±»çš„æ“ä½œäº†ã€‚å¦‚ä¸‹å›¾

----
AbstractAutoProxyCreatorç±»
public Object postProcessBeforeInstantiation(Class<?> beanClass, String beanName) {
    Â·Â·Â·Â·Â·Â·
    if (beanName != null) {
        Object[] specificInterceptors = getAdvicesAndAdvisorsForBean(beanClass, beanName, targetSource);
        Object proxy = createProxy(beanClass, beanName, specificInterceptors, targetSource);
        return proxy;
    }
}

AbstractAutoProxyCreatorç±»
public Object postProcessAfterInitialization(Object bean, String beanName) {
  Â·Â·Â·Â·Â·Â·
  return wrapIfNecessary(bean, beanName, cacheKey);
}
protected Object wrapIfNecessary(Object bean, String beanName, Object cacheKey) {
  Â·Â·Â·Â·Â·Â·
  Object[] specificInterceptors = getAdvicesAndAdvisorsForBean(bean.getClass(), beanName, null);
  if (specificInterceptors != DO_NOT_PROXY) {
      Object proxy = createProxy(bean.getClass(), beanName, specificInterceptors, new SingletonTargetSource(bean));
      this.proxyTypes.put(cacheKey, proxy.getClass());
      return proxy;
  }

    return bean;
}
----
ä»ä¸Šä»£ç ï¼Œæˆ‘ä»¬çŸ¥é“`AbstractAutoProxyCreator`ç±»çš„postProcessBeforeInstantiation()`å’Œ`postProcessAfterInitialization()`æ–¹æ³•éƒ½å¯ä»¥ç”Ÿæˆproxyä»£ç†ç±»ã€‚éƒ½æ˜¯è°ƒç”¨çš„`this.createProxy(..)`æ–¹æ³•ï¼Œè¿™å°±æ˜¯ç”ŸæˆProxyä»£ç†ç±»å…¥å£ï¼Œä»£ç å¦‚ä¸‹
----
protected Object createProxy(Class<?> beanClass, String beanName, Object[] specificInterceptors, TargetSource targetSource) {
    ProxyFactory proxyFactory = new ProxyFactory(); //(1)
    proxyFactory.copyFrom(this);

    if (!proxyFactory.isProxyTargetClass()) {
        // æ£€æŸ¥æ—¶é€šè¿‡æ¥å£è¿˜æ˜¯ç›®æ ‡ç±»åˆ›å»ºproxyä»£ç†ç±»ï¼Œtrueè¡¨ç¤ºé€šè¿‡æ ‡ç±»åˆ›å»º
        if (shouldProxyTargetClass(beanClass, beanName)) {
            proxyFactory.setProxyTargetClass(true);
        }
        else {
            evaluateProxyInterfaces(beanClass, proxyFactory);
        }
    }

    Advisor[] advisors = buildAdvisors(beanName, specificInterceptors);//(2)
    proxyFactory.addAdvisors(advisors);
    proxyFactory.setTargetSource(targetSource);
    customizeProxyFactory(proxyFactory);

    proxyFactory.setFrozen(this.freezeProxy);
    if (advisorsPreFiltered()) {
        proxyFactory.setPreFiltered(true);
    }

    return proxyFactory.getProxy(getProxyClassLoader());
}
----
é¦–å…ˆåˆ›å»ºäº†ä¸€ä¸ª`ProxyFactory`ï¼Œçœ‹åå­—å°±çŸ¥é“å«ä¹‰ï¼šproxyçš„å·¥å‚ã€‚æ³¨æ„è¿™å¥ä»£ç `proxyFactory.copyFrom(this)`ï¼Œå…¶ä¸­çš„thisä¸º`AnnotationAwareAspectJAutoProxyCreator`å¯¹è±¡ï¼Œè¿˜è®°å¾—å—ï¼Œspringé¡¹ç›®åˆå§‹åŒ–æ—¶ï¼Œaopç›¸å…³å®ä¾‹åŒ–`xxxProxyAutoConfiguration`å°±æ˜¯`AnnotationAwareAspectJAutoProxyCreator`ç±»ï¼Œä»–çš„`proxyTargetClass`å’Œ`exposeProxy`ç­‰å±æ€§é€šè¿‡`proxyFactory.copyFrom(this)`ä¼ é€’ç»™`proxyFactory`å±æ€§ã€‚
ç„¶åé€šè¿‡`buildAdvisors(beanName, specificInterceptors)`æ–¹æ³•æ„å»ºadvisor,çœ‹ä»–çš„`specificInterceptors`å‚æ•°ï¼Œå¾€ä¸Šè¿½æº¯å¯ä»¥çŸ¥é“æ˜¯post-processæ–¹æ³•ä¼ é€’è¿›æ¥çš„ï¼Œç»“åˆ https://yaoyuanyy.github.io/2019/04/28/%E7%BB%86%E8%8A%82%E6%8A%A0%E5%87%BA%E8%A1%80%20-%20spring%20boot%20aop%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E8%A7%A3%E6%9E%90%E4%B9%8B%E9%98%B6%E6%AE%B5%E4%B8%89/[spring boot aopè¿‡ç¨‹è§£æä¹‹é˜¶æ®µäºŒï¼šåˆ¤æ–­beanNameæˆ–beanClassæ˜¯å¦ç”ŸæˆProxyä»£ç†ç±»] ï¼Œæˆ‘ä»¬å¯ä»¥çŸ¥é“specificInterceptorsä¹‹ä¸€å°±æ˜¯`InstantiationModelAwarePointcutAdvisorImpl`å®ä¾‹ã€‚æ‰€ä»¥ç”Ÿæˆçš„`advisors`åŒ…å«`InstantiationModelAwarePointcutAdvisorImpl`å®ä¾‹ï¼ŒåŒæ—¶å°†`advisors`èµ‹å€¼ç»™`proxyFactory.addAdvisors(advisors)`ã€‚æ¥ä¸‹æ¥ï¼Œé€šè¿‡`proxyFactory.getProxy(getProxyClassLoader())`ç”Ÿæˆproxyä»£ç†ç±»

== ç”ŸæˆProxyä»£ç†ç±»
çœ‹ä¸‹`proxyFactory.getProxy(getProxyClassLoader())`å†…éƒ¨å®ç°
----
public Object getProxy(ClassLoader classLoader) {
    return createAopProxy().getProxy(classLoader);
}
----
åªæœ‰ä¸€è¡Œä»£ç ï¼Œä½†æ˜¯ç¡®åŒ…å«å¾ˆå¤šå†…å®¹ï¼Œ`createAopProxy()`æ˜¯ä¸€éƒ¨åˆ†ï¼›`getProxy(classLoader)`æ˜¯å¦ä¸€éƒ¨åˆ†

å…ˆè¯´`createAopProxy()`ï¼Œçœ‹å†…éƒ¨å®ç°
----
ProxyFactoryç±»
protected final synchronized AopProxy createAopProxy() {
    return getAopProxyFactory().createAopProxy(this);
}

public AopProxyFactory getAopProxyFactory() {
    // aopProxyFactory = new DefaultAopProxyFactory()
    return this.aopProxyFactory;
}

// DefaultAopProxyFactoryç±»
public AopProxy createAopProxy(AdvisedSupport config) throws AopConfigException {
    if (config.isOptimize() || config.isProxyTargetClass() || hasNoUserSuppliedProxyInterfaces(config)) {
        Class<?> targetClass = config.getTargetClass();
        if (targetClass.isInterface() || Proxy.isProxyClass(targetClass)) {
            return new JdkDynamicAopProxy(config);
        }
        return new ObjenesisCglibAopProxy(config);
    }
    else {
        return new JdkDynamicAopProxy(config);
    }
}
----
`createAopProxyæ–¹æ³•`æ­£å¼åˆ›å»ºxxxAopProxyäº†ï¼Œåˆ°åº•æ˜¯åˆ›å»ºJdkåŠ¨æ€ä»£ç†è¿˜æ˜¯cglibåŠ¨æ€ä»£ç†å‘¢ï¼Œçœ‹æ¡ä»¶ï¼Œæ¡ä»¶ä¹‹ä¸€`proxyTargetClass`çš„å€¼æ˜¯æˆ‘ä»¬æ‰€èƒ½æ§åˆ¶çš„ï¼Œå› ä¸ºå¯ä»¥åœ¨æˆ‘ä»¬çš„é¡¹ç›®å¯åŠ¨ç±»ä¸­åŠ å…¥ç±»ä¼¼
`@EnableAspectJAutoProxy(proxyTargetClass = true, exposeProxy = true)`çš„é…ç½®ã€‚è¿™æ˜¯å…¨å±€è®¾ç½®ã€‚è¿˜æœ‰æ¯æ¬¡åˆ›å»ºproxyçš„è®¾ç½®ï¼š`shouldProxyTargetClass(beanClass, beanName)`ï¼Œé€»è¾‘ä¸ºbeanNameæœ‰æ²¡æœ‰æ¥å£ï¼Œæœ‰æ¥å£`proxyTargetClass=false`ï¼›æ²¡æœ‰æ¥å£ï¼Œ`proxyTargetClass=true`ã€‚å¯¹äºæˆ‘ä»¬å¼€å¤´å®šä¹‰çš„`UserController`ï¼Œç”±äºæ²¡æœ‰æ¥å£ï¼Œæ‰€ä»¥ç”Ÿæˆä»£ç†æ—¶æ˜¯cglibä»£ç†ï¼Œå³`new ObjenesisCglibAopProxy(config)`ï¼Œçœ‹å…¶åŠçˆ¶ç±»æ„é€ å‡½æ•°
----
public CglibAopProxy(AdvisedSupport config){
    this.advised = config;
    this.advisedDispatcher = new AdvisedDispatcher(this.advised);
}
----
`AdvisedSupport`æ˜¯`proxyFactory`çš„çˆ¶ç±»ï¼Œ`CglibAopProxy`æ‹¥æœ‰ä¸€ä¸ª`AdvisedSupport`ç±»å‹çš„advisedå±æ€§ï¼Œè€Œè¿™ä¸ªadvisedæ‹¥æœ‰`advisors`ã€`proxyTargetClass`ã€`exposeProxy`ç­‰ï¼Œæ‰€ä»¥`CglibAopProxy`å°±ç­‰äºæœ‰äº†`advisors`ã€`proxyTargetClass`ã€`exposeProxy`ã€‚

aopProxyå·²ç»åˆ›å»ºäº†ï¼Œä¸‹é¢è¯´å¦ä¸€éƒ¨åˆ†ï¼šgetProxy(classLoader)ï¼Œçœ‹å†…éƒ¨ä»£ç 
----
CglibAopProxyç±»
public Object getProxy(ClassLoader classLoader) {
    Class<?> rootClass = this.advised.getTargetClass();
    Class<?> proxySuperClass = rootClass;
    // è¿™é‡Œåˆ¤æ–­rootClassæ˜¯å¦æ˜¯Cglibä»£ç†æ‰€äº§ç”Ÿçš„ç±»ï¼ˆå†…éƒ¨åˆ¤æ–­rootClassçš„classNameæ˜¯å¦åŒ…å«$$ï¼‰
    if (ClassUtils.isCglibProxyClass(rootClass)) {
        proxySuperClass = rootClass.getSuperclass();
        Class<?>[] additionalInterfaces = rootClass.getInterfaces();
        for (Class<?> additionalInterface : additionalInterfaces) {
            this.advised.addInterface(additionalInterface);
        }
    }

    // æ–¹æ³•æ ¡éªŒï¼Œfinalæ–¹æ³•ä¸èƒ½è¢«ä»£ç†ï¼Œè®°å½•æ—¥å¿—
    validateClassIfNecessary(proxySuperClass, classLoader);

    // Configure CGLIB Enhancer...
    Enhancer enhancer = createEnhancer();
    if (classLoader != null) {
        enhancer.setClassLoader(classLoader);
        if (classLoader instanceof SmartClassLoader &&
                ((SmartClassLoader) classLoader).isClassReloadable(proxySuperClass)) {
            enhancer.setUseCache(false);
        }
    }
    enhancer.setSuperclass(proxySuperClass);
    enhancer.setInterfaces(AopProxyUtils.completeProxiedInterfaces(this.advised));
    enhancer.setNamingPolicy(SpringNamingPolicy.INSTANCE);
    enhancer.setStrategy(new ClassLoaderAwareUndeclaredThrowableStrategy(classLoader));

    Callback[] callbacks = getCallbacks(rootClass);
    Class<?>[] types = new Class<?>[callbacks.length];
    for (int x = 0; x < types.length; x++) {
        types[x] = callbacks[x].getClass();
    }
    // fixedInterceptorMap only populated at this point, after getCallbacks call above
    enhancer.setCallbackFilter(new ProxyCallbackFilter(
            this.advised.getConfigurationOnlyCopy(), this.fixedInterceptorMap, this.fixedInterceptorOffset));
    enhancer.setCallbackTypes(types);

    // Generate the proxy class and create a proxy instance.
    return createProxyClassAndInstance(enhancer, callbacks);
}
----
`getProxy()æ–¹æ³•ä¼šåˆ›å»ºä¸€ä¸ª`Enhancer`å¯¹è±¡ï¼Œè¿™ä¸ªå·¥å…·ç±»è´Ÿè´£ç”Ÿæˆä»£ç†ç±»çš„classï¼Œåªä¸è¿‡è¿™ä¸ªclassä¸æ˜¯æ–‡æœ¬çš„å½¢å¼ï¼Œè€Œæ˜¯åœ¨å†…å­˜ä¸­ã€‚`Enhancer`ä¼šè¢«èµ‹å€¼ç”Ÿæˆproxyä»£ç†ç±»æ˜¯ç”¨äºçš„å±æ€§ï¼Œè¯´ä¸‹è¿™äº›å±æ€§å³ä½œç”¨
- superclassï¼šç›®æ ‡ç±»
- Interfacesï¼šç›®æ ‡ç±»å’Œä»£ç†ç±»çš„æ¥å£
- namingPolicyï¼šç”Ÿæˆä»£ç†ç±»åç§°ç­–ç•¥, å¦‚"xxx\$\$EnhancerBySpringCGLIB$$d2e4a5ae"è¿™ä¸ªæ–‡æœ¬å½¢å¼å°±æ˜¯namingPolicyç”Ÿæˆçš„
- strategyï¼šç”Ÿæˆä»£ç†ç±»classç­–ç•¥
- callbackFilterï¼šè®¾ç½®å¯¹ä¸åŒæ–¹æ³•æ‰§è¡Œä¸åŒçš„å›è°ƒé€»è¾‘ï¼Œæˆ–è€…æ ¹æœ¬ä¸æ‰§è¡Œå›è°ƒ
- callBackTypesï¼šéƒ½ä¼šèµ‹å€¼ç»™Enhancerå¯¹è±¡ç”¨äºç”ŸæˆProxyä»£ç†ç±»ã€‚callBackTypeså°±æ˜¯aop interceptorï¼ŒCGLIBä¸­å¯¹äºæ–¹æ³•çš„æ‹¦æˆªæ˜¯é€šè¿‡å°†è‡ªå®šä¹‰çš„æ‹¦æˆªå™¨ï¼ˆå®ç°MethodInterceptoræ¥å£ï¼‰åŠ å…¥Callbackä¸­å¹¶åœ¨è°ƒç”¨ä»£ç†æ—¶ç›´æ¥æ¿€æ´»æ‹¦æˆªå™¨ä¸­çš„interceptæ–¹æ³•æ¥å®ç°çš„ï¼ŒDynamicAdvisedInterceptorç»§æ‰¿è‡ªMethodInterceptorï¼Œè€ŒåŒ…å«AspectJMethodBeforeAdviceçš„advisedå±æ€§åˆå°è£…åœ¨DynamicAdvisedInterceptorä¸­ï¼ŒDynamicAdvisedInterceptoråˆèµ‹å€¼åˆ°callBackã€‚æ‰€ä»¥å½“æˆ‘ä»¬curlè®¿é—®ç›®æ ‡ç±»æ–¹æ³•æ—¶ä¼šè¢«proxyä»£ç†ç±»çš„æ‹¦æˆªå™¨æ‹¦æˆªï¼Œç»§è€Œä¼šèµ°åˆ‡é¢çš„AspectJMethodBeforeAdviceå¯¹è±¡çš„æ–¹æ³•æ‰§è¡Œåˆ‡é¢é€»è¾‘ã€‚ä¸‹é¢å°±è¯¦ç»†ä¸‹CallbackTypesï¼Œçœ‹getCallbacksæ–¹æ³•ä»£ç ï¼Œå¦‚ä¸‹
----
private Callback[] getCallbacks(Class<?> rootClass) throws Exception {
    // Parameters used for optimization choices...
    boolean exposeProxy = this.advised.isExposeProxy();
    boolean isFrozen = this.advised.isFrozen();
    boolean isStatic = this.advised.getTargetSource().isStatic();

    // Choose an "aop" interceptor (used for AOP calls).
    Callback aopInterceptor = new DynamicAdvisedInterceptor(this.advised);

    // Choose a "straight to target" interceptor. (used for calls that are
    // unadvised but can return this). May be required to expose the proxy.
    Callback targetInterceptor;
    if (exposeProxy) {
        targetInterceptor = isStatic ?
                new StaticUnadvisedExposedInterceptor(this.advised.getTargetSource().getTarget()) :
                new DynamicUnadvisedExposedInterceptor(this.advised.getTargetSource());
    }
    else {
        targetInterceptor = isStatic ?
                new StaticUnadvisedInterceptor(this.advised.getTargetSource().getTarget()) :
                new DynamicUnadvisedInterceptor(this.advised.getTargetSource());
    }

    // Choose a "direct to target" dispatcher (used for
    // unadvised calls to static targets that cannot return this).
    Callback targetDispatcher = isStatic ?
            new StaticDispatcher(this.advised.getTargetSource().getTarget()) : new SerializableNoOp();

    Callback[] mainCallbacks = new Callback[] {
            aopInterceptor,  // for normal advice
            targetInterceptor,  // invoke target without considering advice, if optimized
            new SerializableNoOp(),  // no override for methods mapped to this
            targetDispatcher, this.advisedDispatcher,
            new EqualsInterceptor(this.advised),
            new HashCodeInterceptor(this.advised)
    };

    Callback[] callbacks;
}
----
å¯ä»¥çœ‹åˆ°ï¼Œ`mainCallbacks`æ˜¯æœ€ç»ˆç”Ÿæˆçš„callbacksï¼ŒåŒ…å«7ä¸ªcallbackï¼Œå±äºå‡ ç±»ï¼Œåˆ†åˆ«è¯´ä¸‹
- DynamicAdvisedInterceptorï¼šæ ¸å¿ƒçš„aop interceptorï¼Œaspectçš„AspectJMethodBeforeAdviceå°±è¢«èµ‹å€¼åœ¨è¿™é‡Œã€‚è®¿é—®ä¸šåŠ¡æ–¹æ³•æ—¶å°±ä¼šå…ˆè®¿é—®DynamicAdvisedInterceptorçš„interceptæ–¹æ³•ï¼Œè¯¦æƒ…çœ‹æ­¤æ–¹æ³•
- StaticUnadvisedExposedInterceptorï¼šç”¨äºæ²¡æœ‰advice chainçš„é™æ€ç›®æ ‡
- SerializableNoOp ä»€ä¹ˆæ“ä½œä¹Ÿä¸åšï¼Œä»£ç†ç±»ç›´æ¥è°ƒç”¨è¢«ä»£ç†çš„æ–¹æ³•ä¸è¿›è¡Œæ‹¦æˆª
- Dispatcher æ¯æ¬¡è°ƒç”¨éƒ½ä¼šé‡æ–°åŠ è½½è¢«ä»£ç†çš„å¯¹è±¡
Â·Â·Â·
ä¸‹é¢çœ‹ä¸‹getProxyæ–¹æ³•`createProxyClassAndInstance`æ–¹æ³•ï¼Œè¿™ä¸ªæ–¹æ³•åˆ›å»ºproxy classå¹¶å®ä¾‹åŒ–ä¸ºinstanceï¼Œçœ‹ä¸‹å†…éƒ¨ä»£ç 
----
protected Object createProxyClassAndInstance(Enhancer enhancer, Callback[] callbacks) {
    // åˆ›å»ºclass
    Class<?> proxyClass = enhancer.createClass();
    // å®ä¾‹åŒ–proxyClassä¸ºinstance
    Object proxyInstance = proxyInstance = objenesis.newInstance(proxyClass, enhancer.getUseCache());
    ((Factory) proxyInstance).setCallbacks(callbacks);
    return proxyInstance;
}

private Object createHelper() {
    Object key = KEY_FACTORY.newInstance(this.superclass != null ? this.superclass.getName() : null, ReflectUtils.getNames(this.interfaces), this.filter == ALL_ZERO ? null : new WeakCacheKey(this.filter), this.callbackTypes, this.useFactory, this.interceptDuringConstruction, this.serialVersionUID);
    Object result = super.create(key);
    return result;
}

protected Object create(Object key) {
    ClassLoader loader = this.getClassLoader();
    Map<ClassLoader, AbstractClassGenerator.ClassLoaderData> cache = CACHE;
    AbstractClassGenerator.ClassLoaderData data = (AbstractClassGenerator.ClassLoaderData)cache.get(loader);
    // æ­¤å¤„åˆä½¿ç”¨äº†åŒé‡æ£€æŸ¥æœºåˆ¶(double check and synchronized)æ¥é¿å…é”ç«äº‰ï¼Œè¿™ä¸ªæœºåˆ¶åœ¨javaå’Œspringä¸­å¤šæ¬¡ä½¿ç”¨
    if (data == null) {
        synchronized(AbstractClassGenerator.class) {
            data = (AbstractClassGenerator.ClassLoaderData)cache.get(loader);
            if (data == null) {
                data = new AbstractClassGenerator.ClassLoaderData(loader);
            }
        }
    }
    this.key = key;
    // è·å–class
    Object obj = data.get(this, this.getUseCache());
    return obj instanceof Class ? this.firstInstance((Class)obj) : this.nextInstance(obj);
}

public Object get(AbstractClassGenerator gen, boolean useCache) {
    if (!useCache) {
        // ç”Ÿæˆä»£ç†ç±»
        return gen.generate(this);
    } else {
        Object cachedValue = this.generatedClasses.get(gen);
        return gen.unwrapCachedValue(cachedValue);
    }
}

protected V createEntry(final K key, KK cacheKey, Object v) {
    FutureTask task = new FutureTask(new Callable<V>() {
            public V call() throws Exception {
                // å¼‚æ­¥æ‰§è¡Œä¸‹é¢çš„generate()æ–¹æ³•
                return LoadingCache.this.loader.apply(key);
            }
        });
    }
    task.run();
    return ask.get();
}

// futureæ–°èµ·äº†ä¸€ä¸ªçº¿ç¨‹æ¥å®Œæˆè¿™ä¸ªç”Ÿæˆé€»è¾‘
protected Class generate(AbstractClassGenerator.ClassLoaderData data) {
    String className;
    synchronized(classLoader) {
        // å£°æ˜ä»£ç†ç±»çš„åå­—
        className = this.generateClassName(data.getUniqueNamePredicate());
    }
    // ä½¿ç”¨æŒ‡å®šç­–ç•¥ç”Ÿæˆä»£ç†ç±»å­—èŠ‚æµæ•°ç»„
    byte[] b = this.strategy.generate(this);
    className = ClassNameReader.getClassName(new ClassReader(b));
    // ç”Ÿæˆä»£ç†ç±»
    gen = ReflectUtils.defineClass(className, b, classLoader, protectionDomain);

    return gen;
}

private String generateClassName(Predicate nameTestPredicate) {
    // ä½¿ç”¨æŒ‡å®šçš„nameç”Ÿæˆæ”¿ç­–ç”Ÿæˆä»£ç†ç±»çš„åå­—
    return this.namingPolicy.getClassName(this.namePrefix, this.source.name, this.key, nameTestPredicate);
}

public String getClassName(String prefix, String source, Object key, Predicate names) {
    if (prefix == null) {
        prefix = "org.springframework.cglib.empty.Object";
    } else if (prefix.startsWith("java")) {
        prefix = "$" + prefix;
    }

    String base = prefix + "$$" + source.substring(source.lastIndexOf(46) + 1) + this.getTag() + "$$" + Integer.toHexString(STRESS_HASH_CODE ? 0 : key.hashCode());
    String attempt = base;

    for(int var7 = 2; names.evaluate(attempt); attempt = base + "_" + var7++) {
    }

    return attempt;
}
----

ä¸Šè¿°ä»£ç ç€é‡è´´äº†proxyä»£ç†ç±»çš„åå­—çš„ç”Ÿæˆè¿‡ç¨‹ï¼Œè¿™æ˜¯å¹³æ—¶ä½ debugä»£ç†ç±»æ—¶å¸¸çœ‹è§çš„åå­—ã€‚æ‰€ä»¥äº†è§£åå­—çš„ç”Ÿæˆè¿‡ç¨‹æœ‰åŠ©äºä½ ç†è§£æ›´æ·±å±‚çš„ä¸œè¥¿ã€‚

=== ç”Ÿæˆçš„classæ–‡ä»¶æˆ‘ä»¬å¯ä»¥è¾“å‡ºåˆ°.class
åˆ°è¿™ï¼Œproxyä»£ç†ç±»çš„ç”Ÿæˆè¿‡ç¨‹å°±è¯´å®Œäº†ï¼Œæ•´ä¸ªè¿‡ç¨‹ç”Ÿæˆçš„ä»£ç†ç±»éƒ½æ˜¯åœ¨å†…å­˜çš„ï¼Œæˆ‘ä»¬å¯ä»¥é€šè¿‡è®¾ç½®ï¼Œå°†å†…å­˜ä¸­ç”Ÿæˆçš„ä»£ç†ç±»classå­—èŠ‚ç è¾“å‡ºåˆ°ç¡¬ç›˜çš„.classæ–‡ä»¶ä¸­ï¼Œè¾“å‡ºåˆ°.classçš„æ–¹æ³•è§æ–‡æœ«`æ‰©å±•`éƒ¨åˆ†
----
package com.yy.rest;

import **

public class UserController$$EnhancerBySpringCGLIB$$bd9c2334 extends UserController implements SpringProxy, Advised, Factory {
    private boolean CGLIB$BOUND;
    public static Object CGLIB$FACTORY_DATA;
    private static final ThreadLocal CGLIB$THREAD_CALLBACKS;
    private static final Callback[] CGLIB$STATIC_CALLBACKS;
    private MethodInterceptor CGLIB$CALLBACK_0;
    private MethodInterceptor CGLIB$CALLBACK_1;
    private NoOp CGLIB$CALLBACK_2;
    private Dispatcher CGLIB$CALLBACK_3;
    private Dispatcher CGLIB$CALLBACK_4;
    private MethodInterceptor CGLIB$CALLBACK_5;
    private MethodInterceptor CGLIB$CALLBACK_6;
    private static Object CGLIB$CALLBACK_FILTER;
    private static final Method CGLIB$test$0$Method;
    private static final MethodProxy CGLIB$test$0$Proxy;
    private static final Object[] CGLIB$emptyArgs;
    private static final Method CGLIB$queryOne$1$Method;
    private static final MethodProxy CGLIB$queryOne$1$Proxy;
    private static final Method CGLIB$hello$2$Method;
    private static final MethodProxy CGLIB$hello$2$Proxy;
    private static final Method CGLIB$equals$3$Method;
    private static final MethodProxy CGLIB$equals$3$Proxy;
    private static final Method CGLIB$toString$4$Method;
    private static final MethodProxy CGLIB$toString$4$Proxy;
    private static final Method CGLIB$hashCode$5$Method;
    private static final MethodProxy CGLIB$hashCode$5$Proxy;
    private static final Method CGLIB$clone$6$Method;
    private static final MethodProxy CGLIB$clone$6$Proxy;

     

    final String CGLIB$test$0() {
        return super.test();
    }

    public final String test() {
        try {
            MethodInterceptor var10000 = this.CGLIB$CALLBACK_0;
            if (var10000 == null) {
                CGLIB$BIND_CALLBACKS(this);
                var10000 = this.CGLIB$CALLBACK_0;
            }
            // var10000å®é™…ä¸Šæ˜¯DynamicAdvisedInterceptorç±»
            return var10000 != null ? (String)var10000.intercept(this, CGLIB$test$0$Method, CGLIB$emptyArgs, CGLIB$test$0$Proxy) : super.test();
        } catch (Error | RuntimeException var1) {
            throw var1;
        } catch (Throwable var2) {
            throw new UndeclaredThrowableException(var2);
        }
    }

    ......
}
----
è¿™é‡Œåªåˆ—å‡ºäº†testæ–¹æ³•çš„ä»£ç ï¼Œè¿˜æœ‰å¾ˆå¤šå…¶ä»–çš„æ–¹æ³•ä»£ç ï¼Œè¿è¡Œä½ çš„ä»£ç å°±å¯ä»¥çœ‹åˆ°å…¨éƒ¨äº†

== è®¿é—®ä¸šåŠ¡æ–¹æ³•

ä¸‹é¢æˆ‘ä»¬çœ‹ä¸‹è®¿é—®controlleræ–¹æ³•æ—¶æ˜¯æ€æ ·èµ°å…¥ä»£ç†ç±»çš„æ–¹æ³•çš„ï¼Œåˆæ€ä¹ˆè¿›å…¥åˆ‡é¢çš„æ–¹æ³•çš„ï¼Œæœ€ååˆæ˜¯æ€ä¹ˆè¿›å»ç›®æ ‡æ–¹æ³•çš„

åœ¨æµè§ˆå™¨æˆ–è€…å‘½ä»¤è¡Œè®¿é—®é“¾æ¥ï¼šhttp://localhost:20282/user/testã€‚é€šè¿‡ä¸‹å›¾çš„è°ƒç”¨æ ˆå¯ä»¥çœ‹åˆ°
image::https://raw.githubusercontent.com/yaoyuanyy/MarkdownPhotos/master/img/20201129083820.png[20201129083820]
é¦–å…ˆè®¿é—®äº†`UserController`ä»£ç†ç±»ï¼š`UserController\$\$EnhancerBySpringCGLIB$$bd9c2334`çš„æ–¹æ³•ï¼Œä»`UserController\$\$EnhancerBySpringCGLIB\$\$bd9c2334`çš„æºç æˆ‘ä»¬çŸ¥é“ï¼Œå®ƒçš„testæ–¹æ³•å†…å¼•ç”¨äº†`MethodInterceptor`ç±»å‹å±æ€§ï¼Œæ‰€ä»¥è°ƒç”¨äº†`DynamicAdvisedInterceptor.intercept()`æ–¹æ³•ã€‚æˆ‘ä»¬çœ‹ä¸‹è¿™ä¸ªæ–¹æ³•çš„å†…éƒ¨
----
public Object intercept(Object proxy, Method method, Object[] args, MethodProxy methodProxy) throws Throwable {
    try {
       
        oldProxy = AopContext.setCurrentProxy(proxy);
        targetClass = target.getClass();
       
        // è·å–MethodInterceptoré›†åˆï¼Œè€Œç›¸åº”çš„MethodInterceptoråŒ…å«å¯¹åº”çš„Adviceç±»å‹å±æ€§
        List<Object> chain = this.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass); // (1)
        
        if (chain.isEmpty() && Modifier.isPublic(method.getModifiers())) {
            // ç›´æ¥è°ƒç”¨ç›®æ ‡æ–¹æ³•
            retVal = methodProxy.invoke(target, argsToUse);
        }
        else {
            // We need to create a method invocation...
            retVal = new CglibMethodInvocation(proxy, target, method, args, targetClass, chain, methodProxy).proceed();// (2)
        }
        retVal = processReturnType(proxy, target, method, retVal);
        return retVal;
    }
    finally {
       AopContext.setCurrentProxy(oldProxy);
    }
}

----
æ–¹æ³•(1)å¤„è·å–`MethodIntercetor`é›†åˆï¼Œä»è€Œè·å–å¯¹åº”çš„`dvice`é›†åˆï¼Œå¦‚ä¸‹å›¾
image::https://raw.githubusercontent.com/yaoyuanyy/MarkdownPhotos/master/img/20201129084042.png[20201129084042]


æ–¹æ³•(2)å¤„åˆ›å»ºä¸€ä¸ª`CglibMethodInvocation`ï¼Œ`CglibMethodInvocation`æ‹¥æœ‰ä¸€ä¸ª`MethodInterceptor`é›†åˆï¼Œé€šè¿‡`proceed()`æ–¹æ³•æ‰§è¡Œ`interceptor chain`ã€‚æ‰€æœ‰è¿™é‡Œè¿ç”¨äº†ä¸€ä¸ªè®¾è®¡æ¨¡å¼ï¼š<font color=green size=4>è´£ä»»é“¾æ¨¡å¼çš„å˜ç§</font>ï¼Œç±»ä¼¼`tomcat filter`çš„å½¢å¼ã€‚
å…·ä½“å¦‚ä¸‹ï¼Œè¿è¡Œè¿™ä¸ªé“¾çš„å…¥å£æ˜¯`DynamicAdvisedInterceptor.intercept()`ã€‚è¿™ä¸ªæ–¹æ³•ä¼šè·å–interceptoré›†åˆï¼Œç„¶ååˆ›å»ºä¸€ä¸ª`CglibMethodInvocation`å¯¹è±¡ï¼Œå¹¶æŠŠinterceptoré›†åˆä¼ é€’ç»™`CglibMethodInvocation`å¯¹è±¡çš„`interceptorsAndDynamicMethodMatchers`å±æ€§ï¼Œ ç„¶åè°ƒç”¨`CglibMethodInvocation`å¯¹è±¡çš„proceed()ï¼Œproceed()ä¼šéå†`interceptorsAndDynamicMethodMatchers(å…¶å®å°±æ˜¯interceptoré›†åˆ)`ä»è€Œæ‰§è¡Œæ¯ä¸ª`interceptor.invoke(MethodInvocation)`è‡ªèº«çš„é€»è¾‘ï¼Œå› ä¸ºè¿™ä¸ªæ—¶å€™`MethodInvocation`ä¼šä¼ é€’ç»™`invoke`æ–¹æ³•ï¼Œæ‰€ä»¥æ¯ä¸€ä¸ª`invoke`æ–¹æ³•å†…éƒ¨éƒ½ä¼šæ‰§è¡Œ`MethodInvocation.proceed()`ï¼Œä»è€Œè¿™æ ·å½¢æˆäº†ä¸€ä¸ªé“¾å¼çš„è°ƒç”¨å…³ç³»ã€‚æˆ‘ä»¬çœ‹ä¸‹é“¾å¼ä»£ç ç»“æ„
----
MethodInvocationç±»
public Object proceed() throws Throwable {
    // é“¾å¼è°ƒç”¨ç»ˆç»“ç‚¹
    if (this.currentInterceptorIndex == this.interceptorsAndDynamicMethodMatchers.size() - 1) {
        return invokeJoinpoint();
    }
    // ä»interceptoré›†åˆä¸­è·å–ä¸€ä¸ªinterceptor
    Object interceptorOrInterceptionAdvice =
            this.interceptorsAndDynamicMethodMatchers.get(++this.currentInterceptorIndex);
    // è°ƒç”¨è¿™ä¸ªinterceptor.invokeæ–¹æ³•ï¼Œå¼€å§‹èµ°é“¾äº†
    return ((MethodInterceptor) interceptorOrInterceptionAdvice).invoke(this);
}
MethodInterceptorç±»
public interface MethodInterceptor extends Interceptor {
    
    Object invoke(MethodInvocation invocation) throws Throwable;
}

MethodInterceptorå®ç°ç±»
public Object invoke(MethodInvocation mi) throws Throwable {
    // åˆè°ƒå›MethodInvocation.proceed()æ–¹æ³•
    return mi.proceed();
}

----
ä»¥ä¸Šå°±æ˜¯é“¾å¼è°ƒç”¨çš„ä»£ç ç»“æ„ï¼Œç°åœ¨é€šè¿‡ç»“æ„æµç¨‹å›¾çš„æ–¹æ³•æ›´ç›´è§‚çš„çœ‹ä¸‹
todo


å› ä¸ºè¿™é‡Œæˆ‘ä»¬åªæœ‰ä¸€ä¸ªinterceptorï¼Œæ‰€ä»¥åªæ‰§è¡Œå®ƒäº†ï¼Œå¦‚ä¸‹å›¾
image::https://raw.githubusercontent.com/yaoyuanyy/MarkdownPhotos/master/img/20201129084156.png[20201129084156]

ä»å›¾ä¸­æˆ‘ä»¬çŸ¥é“ï¼Œè°ƒç”¨äº†`MethodBeforeAdvice.before()`æ–¹æ³•ï¼Œ`MethodBeforeAdvice`æŒæœ‰`aspectJAdviceMethod`å±æ€§ï¼Œè¿™ä¸ª`aspectJAdviceMethod`å…¶å®å°±`TimeFeeAspect.doTimeFeeIntercepter()`æ–¹æ³•ï¼Œæ‰€ä»¥beforeæ–¹æ³•ä¼šè¿›å»æˆ‘ä»¬å®šä¹‰çš„Aspectåˆ‡é¢ï¼Œä»è€Œå®ç°äº†åˆ‡å…¥æ–¹æ³•çš„åŠŸèƒ½

== spring aop å…³é”®è¯
ç°åœ¨æˆ‘ä»¬èµ°äº†ä¸€éspring aopç”Ÿæˆä»£ç†ç±»çš„é€»è¾‘å’Œä»£ç å®ç°æ–¹å¼ï¼Œæ„Ÿè§‰é—¨æ¸…äº†ã€‚ä½†åƒä¸‡ä¸è¦å¿½ç•¥æ—¶é—´è€äººçš„é­”åŠ›ï¼Œä¸ä¹…çš„ä»¥åä½ å¯èƒ½æ²¡æœ‰è¿™ä¹ˆæ¸…æ™°çš„è®°å¿†äº†ï¼Œä¸€äº›ç‚¹å¯èƒ½å·²ç»å¿˜è®°äº†ã€‚è¿™ä¸ªæ—¶å€™å…³é”®è¯ä¼šç»™ä½ æŒ‡å¼•å’Œä½œä¸ºå›å¿†çš„é’¥åŒ™
spring aop å…³é”®è¯

1. AdvisedSupport
----
1. Base class for AOP proxy configuration managers
2. ProxyConfigçš„å­ç±»ï¼Œåˆæ˜¯ProxyFactoryçš„çˆ¶ç±»
3. åŒ…å«Advisorï¼Œè€ŒadvisoråˆåŒ…å«advice
----

2.AbstractAutoProxyCreator
----
1. å‰åç½®æ–¹æ³•ç”Ÿæˆä»£ç†ç±»é€»è¾‘
2. postProcessBeforeInstantiation()
3. postProcessAfterInitialization()
----

3.InstantiationModelAwarePointcutAdvisor
----
çœ‹åå­—çŸ¥é“ä»–æ˜¯ä¸€ä¸ªadvisorï¼Œæ˜¯å®ƒæºå¸¦è€…pointcutå’Œadviceï¼Œä»abstractAutoProxyCreaterçš„åç½®æ–¹æ³•ä¼ é€’ç»™åˆ°ProxyFacatoryï¼Œå†ä¼ é€’åˆ°CglibMethodInvocationä¸­
1. åŒ…å«pointcut(expression)
2. åŒ…å«adviceï¼šTimeFeeAspect.doTimeFeeIntercepter
----

4. MethodInterceptorå†…éƒ¨ç±»DynamicAdvisedInterceptor
----
DynamicAdvisedInterceptoræ˜¯interceptorè´£ä»»é“¾æ¨¡å¼çš„å¼€å§‹å¤„ã€‚ä»£ç†ç±»æŠŠå®ƒåˆ‡å…¥åˆ°çœŸå®å¯¹è±¡æ–¹æ³•å‰åï¼Œæ‰§è¡Œåˆ‡å…¥åŠŸèƒ½
----

5. MethodBeforeAdvice

== æ‰©å±• - jvmå†…å­˜ä¸­ç”Ÿæˆçš„ä»£ç†ç±»classå­—èŠ‚ç è¾“å‡ºåˆ°ç¡¬ç›˜.classæ–‡ä»¶

ä»¥ä¸‹ä¸¤ç§æ–¹æ³•çš„ä»£ç æ”¾åœ¨mainæ–¹æ³•ä¸­
==== æ–¹æ³•ä¸€
----
è¯¥è®¾ç½®ç”¨äºè¾“å‡ºcglibåŠ¨æ€ä»£ç†äº§ç”Ÿçš„ç±»
System.setProperty(DebuggingClassWriter.DEBUG_LOCATION_PROPERTY, "/Users/xx/skyler");

è¯¥è®¾ç½®ç”¨äºè¾“å‡ºjdkåŠ¨æ€ä»£ç†äº§ç”Ÿçš„ç±»ï¼Œè¾“å‡ºçš„æ–‡ä»¶è·¯å¾„ä¸ºyour projectä¸‹ã€‚å¦‚æˆ‘çš„é¡¹ç›®æ˜¯java_example, $ProxyX.classåœ¨java_example/com/sun/proxy/ä¸‹
System.getProperties().put("sun.misc.ProxyGenerator.saveGeneratedFiles", "true");
----
 

=== æ–¹æ³•äºŒ
----
writeProxyClass2File("/Users/xx/skyler/project/mytest/java_example/target/classes/com/yy/example/pattern_mode/structure/proxy/dynamic_proxy/spring_aop/$Proxy2.class");

/**
  * å°†å†…å­˜ä¸­çš„$ProxyXå¯¹è±¡ç”Ÿæˆ$ProxyX.classæ–‡ä»¶å­˜æ”¾åˆ°æŒ‡å®šçš„ç¡¬ç›˜ä½ç½®
  *
  * @param outPath å­˜æ”¾åˆ°çš„ç¡¬ç›˜ä½ç½®
  */
public static void writeProxyClass2File(String outPath) {
    byte[] bytes = ProxyGenerator.generateProxyClass("$Proxy2", new Class[]{House.class});
    try (OutputStream outputStream = new FileOutputStream(new File(outPath))) {
        outputStream.write(bytes);
        outputStream.flush();
    } catch (FileNotFoundException e) {
        e.printStackTrace();
    } catch (IOException e) {
        e.printStackTrace();
    }
}
----  