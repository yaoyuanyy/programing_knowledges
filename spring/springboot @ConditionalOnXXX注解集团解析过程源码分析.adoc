= springboot @ConditionalOnXXXæ³¨è§£é›†å›¢è§£æè¿‡ç¨‹æºç åˆ†æ
:toc: left
:toc-title: ç›®å½•
:tip-caption: ğŸ’¡
:note-caption: â„¹ï¸
:important-caption: â—
:caution-caption: ğŸ”¥
:warning-caption: âš ï¸
// :tip-caption: :bulb:
// :note-caption: :information_source:
// :important-caption: :heavy_exclamation_mark:	
// :caution-caption: :fire:
// :warning-caption: :warning:
:icons: font

Doc writer yaoyihao1@gmail.com

- å…¥å£ï¼šå½“@ConditionalOnXXXä½œç”¨äºå¸¦æœ‰@Configurationçš„ç±»æˆ–å¸¦æœ‰@Beançš„æ–¹æ³•æ—¶ï¼Œè§£æå…¥å£ä¸ºConfigurationClassParser.processConfigurationClass(ConfigurationClass)æ–¹æ³•

----
protected void processConfigurationClass(ConfigurationClass configClass) throws IOException {
    // è·å–@Conditionalæ³¨è§£ï¼Œæ£€éªŒconditionæ¡ä»¶æ˜¯å¦åŒ¹é…ã€‚åŒ¹é…åˆ™é€šè¿‡ï¼Œå¾€ä¸‹æ‰§è¡Œï¼›å¦åˆ™return
	if (this.conditionEvaluator.shouldSkip(configClass.getMetadata(), ConfigurationPhase.PARSE_CONFIGURATION)) {
		return;
	}

	ConfigurationClass existingClass = this.configurationClasses.get(configClass);
	
	......
	
	// Recursively(é€’å½’) process the configuration class and its superclass hierarchy.
	SourceClass sourceClass = asSourceClass(configClass);
	do {
	// æ¥ç€å¤„ç†sourceClassçš„any member (nested) classesã€ @PropertySourceã€@ComponentScan
	// @Importã€@ImportResourceã€@Beanã€Process superclass
		sourceClass = doProcessConfigurationClass(configClass, sourceClass);
	}
	while (sourceClass != null);

	this.configurationClasses.put(configClass, configClass);
}
----
	
- æ·±å…¥åˆ†æ
	conditionEvaluator.shouldSkip()ä½œä¸ºconditionåˆ¤æ–­çš„æ€»å…¥å£ï¼Œæ­¤æ–¹æ³•ä¼ å…¥Metadataå’ŒConfigurationPhaseï¼Œæ–¹æ³•ä»£ç åªåˆ—å‡ºå…³é”®é€»è¾‘

----
public boolean shouldSkip(AnnotatedTypeMetadata metadata, ConfigurationPhase phase) {
	if (metadata == null || !metadata.isAnnotated(Conditional.class.getName())) {
		return false;
	} 
	
   // ä»metadataæ‹¿åˆ°conditions(åŒ…å«@ConditionalOnXXXçš„é›†åˆ)
	for (Condition condition : conditions) {
		if (requiredPhase == null || requiredPhase == phase) {
		// å…³é”®ä»£ç ï¼Œå…·ä½“çš„åŒ¹é…é€»è¾‘
			if (!condition.matches(this.context, metadata)) {
				return true;
			}
		}
	}

	return false;
}
----
æ¯ä¸ª@ConditionalOnXXXçš„åŒ¹é…ç»“æœé€šè¿‡Condition.matches()æ–¹æ³•å¾—å‡ºç»“æœï¼Œå…·ä½“çš„åŒ¹é…é€»è¾‘å°±åœ¨è¿™ä¸ªæ–¹æ³•é‡Œã€‚å¯ä»¥çœ‹å‡ºï¼šåªè¦æœ‰ä¸€ä¸ªConditionä¸åŒ¹é…ï¼Œæ–¹æ³•ç›´æ¥è¿”å›trueã€‚è¿™é‡Œçš„Conditionå®é™…ä¸Šæ˜¯SpringbootCondition,è€ŒSpringbootConditionæ˜¯OnXXXConditionçš„çˆ¶ç±»ï¼Œè¿™æ˜¯ä¸€ä¸ªæ¨¡æ¿æ–¹æ³•æ¨¡å¼ã€‚æ³¨æ„ä¸€ç‚¹ï¼š@ConditionalOnXXXå¯¹åº”OnXXXConditionç±»ï¼Œæ–¹æ³•å†…éƒ¨å¦‚ä¸‹

----
public final boolean matches(ConditionContext context,AnnotatedTypeMetadata metadata) {
    String classOrMethodName = getClassOrMethodName(metadata);
    // æ¯ä¸ªOnXXXConditionç±»è°ƒç”¨è‡ªå·±çš„getMatchOutcome()æ–¹æ³•ï¼Œoutcomeå°è£…äº†åŒ¹é…ç»“æœ
	ConditionOutcome outcome = getMatchOutcome(context, metadata);
	// åŒ¹é…ç»“æœæ”¾å…¥ConditionEvaluationReportä¸­ï¼Œç”¨äºdebugæ—¥å¿—è¾“å‡º
	recordEvaluation(context, classOrMethodName, outcome);
	return outcome.isMatch();
}
----

åˆ°è¿™é‡Œéƒ½æ˜¯é€šç”¨çš„åŒ¹é…é€»è¾‘ï¼Œå…·ä½“çš„OnXXXConditionè‡ªå·±çš„å±æ€§ï¼Œå­—æ®µåŒ¹é…éƒ½æœ‰è‡ªå·±çš„getMatchOutcome()æ–¹æ³•è´Ÿè´£ï¼Œè¿™é‡Œä»¥@ConditionalOnProperty(prefix = "spring.aop", name = "auto", havingValue = "true", matchIfMissing = true)ä¸ºä¾‹è¯´ä¸‹OnPropertyCondition.getMatchOutcome()çš„é€»è¾‘ï¼Œå¦‚ä¸‹
----
public ConditionOutcome getMatchOutcome(ConditionContext context,
		AnnotatedTypeMetadata metadata) {
	List<AnnotationAttributes> allAnnotationAttributes = annotationAttributesFromMultiValueMap(
			metadata.getAllAnnotationAttributes(ConditionalOnProperty.class.getName()));
	for (AnnotationAttributes annotationAttributes : allAnnotationAttributes) {
		ConditionOutcome outcome = determineOutcome(annotationAttributes,context.getEnvironment());
		(outcome.isMatch() ? match : noMatch).add(outcome.getConditionMessage());
	}
	if (!noMatch.isEmpty()) {
		return ConditionOutcome.noMatch(ConditionMessage.of(noMatch));
	}
	return ConditionOutcome.match(ConditionMessage.of(match));
}
	
private ConditionOutcome determineOutcome(AnnotationAttributes annotationAttributes,
		PropertyResolver resolver) {
	Spec spec = new Spec(annotationAttributes);
	spec.collectProperties(resolver, missingProperties, nonMatchingProperties);
}
    
private void collectProperties(PropertyResolver resolver, List<String> missing,List<String> nonMatching) {
		if (this.relaxedNames) {
			resolver = new RelaxedPropertyResolver(resolver, this.prefix);
		}
		for (String name : this.names) {
			String key = (this.relaxedNames ? name : this.prefix + name);
			if (resolver.containsProperty(key)) {
				if (!isMatch(resolver.getProperty(key), this.havingValue)) {
					nonMatching.add(name);
				}
			}
			else {
				if (!this.matchIfMissing) {
					missing.add(name);
				}
			}
	}
}
		
----
resolveræ˜¯ç”¨æ¥è§£æEnvironmentä¸­é…ç½®æ–‡ä»¶çš„ï¼Œæ‰€ä»¥collectProperties()æ–¹æ³•çš„é€»è¾‘ä¸ºï¼šå¦‚æœresolveråœ¨é…ç½®æ–‡ä»¶ä¸­æ‰¾åˆ°äº†spring.aop.autoè¿™ä¸ªkeyä¸”spring.aop.auto=havingValueåˆ™åŒ¹é…æˆåŠŸï¼Œæˆ–è€…é…ç½®æ–‡ä»¶ä¸­æ²¡æœ‰spring.aop.autoè¿™ä¸ªkeyä¸”matchIfMissingä¸ºtrueåˆ™åŒ¹é…æˆåŠŸï¼Œå…¶ä»–ä»»ä½•é€»è¾‘éƒ½æ˜¯åŒ¹é…å¤±è´¥ã€‚

- çœ‹åˆ°è¿™é‡Œï¼Œæ˜¯ä¸æ˜¯å¯¹æˆ‘ä»¬æ€»è¿·æƒ‘çš„havingValueå’ŒmatchIfMissingçš„å«ä¹‰å½»åº•çš„æ˜ç™½äº†ã€‚æ‰€ä»¥ï¼Œèµ°æºç å¯ä»¥ä¸ºä½ è§£æƒ‘