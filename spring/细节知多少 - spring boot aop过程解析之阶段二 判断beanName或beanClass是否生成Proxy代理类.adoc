= ç»†èŠ‚çŸ¥å¤šå°‘ - spring boot aopè¿‡ç¨‹è§£æä¹‹é˜¶æ®µäºŒ åˆ¤æ–­beanNameæˆ–beanClassæ˜¯å¦ç”ŸæˆProxyä»£ç†ç±»
:toc: left
:toc-title: ç›®å½•
:tip-caption: ğŸ’¡
:note-caption: â„¹ï¸
:important-caption: â—
:caution-caption: ğŸ”¥
:warning-caption: âš ï¸
// :tip-caption: :bulb:
// :note-caption: :information_source:
// :important-caption: :heavy_exclamation_mark:	
// :caution-caption: :fire:
// :warning-caption: :warning:
:icons: font

Doc writer yaoyihao1@gmail.com


æ­¤ç¯‡æ˜¯ç»†èŠ‚çŸ¥å¤šå°‘-spring boot aopè¿‡ç¨‹è§£æç³»åˆ—çš„ç¬¬äºŒç¯‡ï¼Œå³ç¬¬äºŒé˜¶æ®µ

æˆ‘ä»¬æŠŠspring bootçš„aopå®ç°åˆ†ä¸ºä¸‰ä¸ªé˜¶æ®µ

- AnnotationAwareAspectJAutoProxyCreatoråŠ è½½(åˆå§‹åŒ–å’Œå®ä¾‹åŒ–)é˜¶æ®µ
- AnnotationAwareAspectJAutoProxyCreatorä½¿ç”¨post-processåŸºäº@AspectéªŒè¯beanNameæˆ–beanClassæ˜¯å¦å¯ä»¥ç”ŸæˆProxyä»£ç†ç±»é˜¶æ®µ
- CglibAopProxyæˆ–JdkDynamicAopProxyç”ŸæˆProxyä»£ç†ç±»é˜¶æ®µ

ä¸Šä¸€ç¯‡ä¸­ï¼Œç¬”è€…å’Œå¤§å®¶ä¸€èµ·å­¦ä¹ äº† https://yaoyuanyy.github.io/2019/04/21/%E7%BB%86%E8%8A%82%E6%8A%A0%E5%87%BA%E8%A1%80%20-%20spring%20boot%20aop%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E8%A7%A3%E6%9E%90%E4%B9%8B%E9%98%B6%E6%AE%B5%E4%B8%80[spring boot aopè¿‡ç¨‹è§£æä¹‹é˜¶æ®µä¸€: AnnotationAwareAspectJAutoProxyCreatoråŠ è½½]ã€‚è¿™ç¯‡æˆ‘ä»¬è¯´ä¸‹é˜¶æ®µäºŒï¼š<B>åˆ¤æ–­beanNameæˆ–beanClassæ˜¯å¦ç”ŸæˆProxyä»£ç†ç±»</B>ã€‚åœ¨spring bootä¸­ï¼Œæ¯ä¸ªç±»åœ¨ç”Ÿæˆä»£ç†ç±»æ—¶ï¼Œéƒ½ä¼šåˆ¤æ–­æ˜¯å¦å¯ä»¥ç”Ÿæˆä»£ç†ç±»

== å¸¦ç€é—®é¢˜å­¦ä¹ 
> å¸¦ç€é—®é¢˜å­¦ä¹ å¾€å¾€èµ·åˆ°æ›´å¥½çš„æ•ˆæœ

é—®é¢˜ï¼š
----
1. spring aopæ˜¯å¦‚æœè·å–å’Œè§£æ@Aspectæ³¨è§£çš„
2. spring aopæ˜¯å¦‚æœè·å–å’Œè§£æ@Pointcutæ³¨è§£çš„
3. @Pointcutæ³¨è§£çš„execution(expression)å­˜æ”¾åœ¨å“ªä¸ªå¯¹è±¡ï¼Œä»€ä¹ˆæ—¶å€™è¢«ä½¿ç”¨
----

== ç”¨ä¾‹ä»£ç 
å®é™…å·¥ä½œä¸­ï¼Œæˆ‘ä»¬éƒ½å†™è¿‡@Aspectçš„ä»£ç å§ã€‚æˆ‘ä»¬è¿™é‡Œå®šä¹‰ä¸€ä¸ªï¼Œä¾¿äºåé¢çŸ¥è¯†ç‚¹é˜è¿°
----
@Aspect
@Component
public class TimeFeeAspect {

    @Pointcut("execution(* com.yy..rest..*(..))")
    public void cut(){}

    @Before("cut()")
    public void doTimeFeeIntercepter(JoinPoint joinPoint) throws Throwable {
        System.out.println("args:" + joinPoint.getArgs());
        System.out.println("target" + joinPoint.getTarget().toString());
    }

}
----
å¦‚ä¸Šä»£ç ï¼Œå®šä¹‰ä¸€ä¸ªAspectç±»ï¼Œç›®çš„æ˜¯å¯¹`com.yy..rest`åŒ…ä¸‹æ‰€æœ‰çš„ç±»çš„è®¿é—®éƒ½ç»è¿‡åˆ‡é¢ï¼Œä¹Ÿå°±æ˜¯è¦èµ°`doTimeFeeIntercepter()`æ–¹æ³•ã€‚
ä¸‹é¢æˆ‘ä»¬é€šè¿‡debugè¿½è¸ªæºç ï¼Œäº†è§£å®ç°åŸç†ã€‚

== éªŒè¯å’Œç”Ÿæˆä»£ç†çš„å…¥å£
é€šè¿‡ã€Šspring boot aopè¿‡ç¨‹è§£æä¹‹é˜¶æ®µä¸€: AnnotationAwareAspectJAutoProxyCreatoråŠ è½½ã€‹æˆ‘ä»¬çŸ¥é“ä¸€ä¸ªbeanè¦ç”Ÿæˆä»£ç†çš„å…¥å£åœ¨`AnnotationAwareAspectJAutoProxyCreator`çš„å‰åç½®æ–¹æ³•ä¸­å®ç°ã€‚ä¸ºäº†æ–¹ä¾¿æˆ‘å®šä¹‰äº†ä¸€ä¸ª`@Component
CustomInstantiationAwarePostProcessorAdapter`ã€‚åœ¨`CustomInstantiationAwarePostProcessorAdapter`è¢«åˆ›å»ºæˆbeanè¿‡ç¨‹ä¸­ï¼Œç”±äºpost-processæœºåˆ¶å½“ç»è¿‡`AnnotationAwareAspectJAutoProxyCreatorçš„postProcessBeforeInstantiation()å’ŒpostProcessAfterInitialization()`æ–¹æ³•æ—¶ï¼Œéƒ½ä¼šè¿›è¡Œä»£ç†ç±»çš„åˆ›å»ºé€»è¾‘ï¼Œå³åˆ¤æ–­æ˜¯å¦èƒ½åˆ›å»ºï¼Œå¦‚æœé€šè¿‡åˆ™åˆ›å»ºã€‚ç°åœ¨è¯´ä¸‹è¿™ä¸¤ä¸ªæ–¹æ³•ç”Ÿæˆä»£ç†ç±»é€»è¾‘çš„æºç 

=== postProcessBeforeInstantiation()
è¿›å…¥æ–¹æ³•ï¼ŒéªŒè¯é€»è¾‘å°±å¼€å§‹äº†ï¼Œå¦‚ä¸‹å›¾ä»£ç 
image::https://raw.githubusercontent.com/yaoyuanyy/MarkdownPhotos/master/img/20201029210116.png[20201029210116]
éªŒè¯é€»è¾‘ä¸ºbeanClassæ˜¯å¦ä¸ºaopåŸºç¡€ç»“æ„ç±»å‹æˆ–è€…æ˜¯å¦å¯ä»¥è·³è¿‡ã€‚ç”±äºbeanClassä¸æ˜¯Pointcutã€Adviceã€Advisorç­‰aopåŸºç¡€ç»“æ„çš„å­ç±»ï¼Œæ‰€ä»¥isInfrastructureClass(beanClass)è¿”å›falseï¼Œä»£ç è¿›å…¥shouldSkip(beanClass, beanName)æ–¹æ³•é€»è¾‘ï¼Œè¿™ä¸ªå¾ˆé‡è¦çš„æ–¹æ³•ï¼Œé€»è¾‘å¾ˆå¤æ‚ã€‚è¿›å…¥æ–¹æ³•å†…éƒ¨
----
@Override
protected boolean shouldSkip(Class<?> beanClass, String beanName) {
    //advisorå€™é€‰è€…
	List<Advisor> candidateAdvisors = findCandidateAdvisors();
	for (Advisor advisor : candidateAdvisors) {
		if (advisor instanceof AspectJPointcutAdvisor) {
			if (((AbstractAspectJAdvice) advisor.getAdvice()).getAspectName().equals(beanName)) {
				return true;
			}
		}
	}
	return super.shouldSkip(beanClass, beanName);
}
----
é¦–å…ˆè·å–advisorå€™é€‰è€…åˆ—è¡¨ï¼Œç„¶åéå†ï¼Œå¦‚æœæœ‰AspectNameç­‰äºbeanNameï¼Œè¯´æ˜è¿™ä¸ªbeanNameæ˜¯Aspectï¼Œä¸ç”¨ç”Ÿæˆä»£ç†ï¼Œæ–¹æ³•è¿”å›trueï¼Œå¦åˆ™èµ°çˆ¶ç±»é€»è¾‘(è¿”å›false)ã€‚æŸ¥çœ‹è·å–advisorå€™é€‰è€…æ–¹æ³•findCandidateAdvisors()
----
@Override
protected List<Advisor> findCandidateAdvisors() {
	// Add all the Spring advisors found according to superclass rules.
	List<Advisor> advisors = super.findCandidateAdvisors();
	// Build Advisors for all AspectJ aspects in the bean factory.
	advisors.addAll(this.aspectJAdvisorsBuilder.buildAspectJAdvisors());
	return advisors;
}
----
æ–¹æ³•å†…éƒ¨é€»è¾‘å¾ˆç®€å•ï¼Œä½†æ˜¯æ„ä¹‰é‡å¤§ï¼Œä»ä¸¤ä¸ªè§’åº¦è·å–Advisorã€‚è§’åº¦ä¸€æ˜¯ä»beanFactoryå®¹å™¨ä¸­è·å–Advisorç±»ï¼›è§’åº¦äºŒæ˜¯ä»beanFactoryå®¹å™¨ä¸­è·å–Aspectç±»ã€‚å…ˆçœ‹å…¶ä¸€
----
public List<Advisor> findAdvisorBeans() {
 	String[] advisorNames = BeanFactoryUtils.beanNamesForTypeIncludingAncestors(
					this.beanFactory, Advisor.class, true, false);
			......
			
    List<Advisor> advisors = new LinkedList<Advisor>();
	for (String name : advisorNames) {
		if (isEligibleBean(name)) {
	       advisors.add(this.beanFactory.getBean(name, Advisor.class));
		}
	}
	return advisors;
}
----
è¿™é‡Œåªåˆ—å‡ºäº†å…³é”®ä»£ç ï¼Œå¯ä»¥çœ‹åˆ°ï¼Œä»beanFactoryå®¹å™¨ä¸­è·å–Advisorçš„å­ç±»nameé›†åˆï¼Œç„¶åéªŒè¯ä¸‹nameæ˜¯å¦åˆæ ¼ï¼Œåˆæ ¼åè·å–nameå¯¹åº”çš„beanã€‚ä½†æ˜¯å®é™…debugä»£ç æ—¶ï¼Œè¿™æ­¥å´æ²¡æœ‰è·å–åˆ°Advisorçš„å­ç±»ï¼Œæ‰€ä»¥è¿”å›çš„æ˜¯ç©ºlistã€‚
å›åˆ°findCandidateAdvisors()æ–¹æ³•,çœ‹å…¶äºŒ

----
BeanFactoryAspectJAdvisorsBuilderç±»
public List<Advisor> buildAspectJAdvisors() {
  List<String> aspectNames = new LinkedList<String>();
      // ä»beanFactoryä¸­è·å–æ‰€æœ‰çš„beanName
      String[] beanNames = BeanFactoryUtils.beanNamesForTypeIncludingAncestors(
          this.beanFactory, Object.class, true, false);
      // éå†beanNameé›†åˆå¯¹beanNameè¿›è¡Œåˆæ ¼æ€§éªŒè¯
      for (String beanName : beanNames) {
        // é»˜è®¤true,é™¤éæœ‰aop:includeä½¿ç”¨
        if (!isEligibleBean(beanName)) { //(1)
          continue;
        }
    
        Class<?> beanType = this.beanFactory.getType(beanName);
        if (beanType == null) {
          continue;
        }
        if (this.advisorFactory.isAspect(beanType)) { //(2)
          aspectNames.add(beanName);
          AspectMetadata amd = new AspectMetadata(beanType, beanName);
          // å•ä¾‹ bean
          if (amd.getAjType().getPerClause().getKind() == PerClauseKind.SINGLETON) {
            MetadataAwareAspectInstanceFactory factory =
                new BeanFactoryAspectInstanceFactory(this.beanFactory, beanName); //(3)
            List<Advisor> classAdvisors = this.advisorFactory.getAdvisors(factory); //(4)
            advisors.addAll(classAdvisors);
          }
          else { // å•ä¾‹Prototype bean
            MetadataAwareAspectInstanceFactory factory =
                new PrototypeAspectInstanceFactory(this.beanFactory, beanName);
            advisors.addAll(this.advisorFactory.getAdvisors(factory));
          }
        }
      }
      return advisors;
       
}
----
ä»£ç (2)å¤„ï¼Œåˆ¤æ–­beanTypeæ˜¯å¦ä¸ºAspectï¼Œå®ç°é€»è¾‘ä¸º`AnnotationUtils.findAnnotation(clazz, Aspect.class) != null`ï¼Œå¼€å¤´æˆ‘å®šä¹‰äº†ä¸€ä¸ªTimeFeeAspectåˆ‡é¢ç±»ï¼Œæ‰€ä»¥è¿™é‡Œåªæœ‰TimeFeeAspectç¬¦åˆæ¡ä»¶ï¼Œè¿›å…¥ifå—é‡Œé¢
ä»£ç (3)å¤„ï¼Œæ„é€ ä¸€ä¸ªå¸¦æœ‰Aspect metadataå’ŒbeanFactoryçš„BeanFactoryAspectInstanceFactoryå®ä¾‹ï¼Œä¼ ç»™å…³é”®ä»£ç (4)å—ï¼Œçœ‹ä»£ç (4)å†…éƒ¨é€»è¾‘
----
ReflectiveAspectJAdvisorFactoryç±»
public List<Advisor> getAdvisors(MetadataAwareAspectInstanceFactory aspectInstanceFactory) {
	Class<?> aspectClass = aspectInstanceFactory.getAspectMetadata().getAspectClass();
	String aspectName = aspectInstanceFactory.getAspectMetadata().getAspectName();

	MetadataAwareAspectInstanceFactory lazySingletonAspectInstanceFactory =
			new LazySingletonAspectInstanceFactoryDecorator(aspectInstanceFactory);

	List<Advisor> advisors = new LinkedList<Advisor>();
	// è·å–aspectClassçš„æ–¹æ³•é›†åˆ
	for (Method method : getAdvisorMethods(aspectClass)) {
		Advisor advisor = getAdvisor(method, lazySingletonAspectInstanceFactory, advisors.size(), aspectName); // å…³é”®ä»£ç 
		if (advisor != null) {
			advisors.add(advisor);
		}
	}
	return advisors;

}
----
è¿™ä¸ªæ–¹æ³•çš„ç›®çš„å¾ˆæ˜ç¡®ï¼šè·å–advisorã€‚æ–¹æ³•è§£æå‡ºå…¥å‚aspectClassçš„methodsï¼Œéå†methodsä»è€Œè·å–advisoré›†åˆï¼ŒadvisoråŒ…å«adviceå’Œpointcutã€‚
<font color=green>è·å–methodsçš„æ–¹æ³•å€¼å¾—è¯´ä¸‹</font>
----
private List<Method> getAdvisorMethods(Class<?> aspectClass) {
	final List<Method> methods = new LinkedList<Method>();
	ReflectionUtils.doWithMethods(aspectClass, new ReflectionUtils.MethodCallback() {
		@Override
		public void doWith(Method method) throws IllegalArgumentException {
			if (AnnotationUtils.getAnnotation(method, Pointcut.class) == null) {
				methods.add(method);
			}
		}
	});
	Collections.sort(methods, METHOD_COMPARATOR);
	return methods;
}
----
è¿™æ®µæ–¹æ³•é€»è¾‘æ˜¯é€šç”¨çš„ï¼šè·å–ä¸€ä¸ªç±»ä¸­å¸¦æœ‰(ä¸å¸¦æœ‰)æŸæ³¨è§£çš„æ–¹æ³•é›†åˆï¼Œ<font color=green>è¿™ä¸ªé€»è¾‘å¯ä»¥è½»æ˜“çš„ä¸ºä½ å®é™…æ‰€ç”¨</font>ã€‚
æ ¹æ®methodè·å–advisorçš„getAdvisor(..)æ–¹æ³•å°±æ˜¯æ ¸å¿ƒé€»è¾‘äº†ï¼Œçœ‹å…¶å†…éƒ¨
----
ReflectiveAspectJAdvisorFactoryç±»
public Advisor getAdvisor(Method candidateAdviceMethod, MetadataAwareAspectInstanceFactory aspectInstanceFactory,
		int declarationOrderInAspect, String aspectName) {

    // éªŒè¯aspectClassæ˜¯å¦æœ‰@Aspectæ³¨è§£ï¼Œå…¶çˆ¶ç±»æ˜¯å¦æ²¡æœ‰Aspectæ³¨è§£
    validate(aspectInstanceFactory.getAspectMetadata().getAspectClass());
    // æ ¸å¿ƒï¼šç”ŸæˆPointCut
	AspectJExpressionPointcut expressionPointcut = getPointcut(
			candidateAdviceMethod, aspectInstanceFactory.getAspectMetadata().getAspectClass());
	
	return new InstantiationModelAwarePointcutAdvisorImpl(expressionPointcut, candidateAdviceMethod,
			this, aspectInstanceFactory, declarationOrderInAspect, aspectName);
}
----
æ–¹æ³•é¦–å…ˆéªŒè¯åï¼Œæ ¹æ®adviceMethodå’ŒaspectClassç”ŸæˆPointCutï¼Œç„¶åæ„é€ æˆ`InstantiationModelAwarePointcutAdvisorImpl`å®ä¾‹ã€‚é¦–å…ˆçœ‹ç”Ÿæˆ`PointCut`çš„é€»è¾‘
----
ReflectiveAspectJAdvisorFactoryç±»
private AspectJExpressionPointcut getPointcut(Method candidateAdviceMethod, Class<?> candidateAspectClass) {
    // è·å–methodçš„Advice,å³Before.class, Around.class, After.class, AfterReturning.class, AfterThrowing.class
    // AspectJAnnotationåŒ…æ‹¬å…·ä½“ç±»å‹çš„Adviceå’ŒPointCutçš„expression
	AspectJAnnotation<?> aspectJAnnotation =
			AbstractAspectJAdvisorFactory.findAspectJAnnotationOnMethod(candidateAdviceMethod);
   // æ„é€ PointCut
   AspectJExpressionPointcut ajexp =
			new AspectJExpressionPointcut(candidateAspectClass, new String[0], new Class<?>[0]);
	ajexp.setExpression(aspectJAnnotation.getPointcutExpression());
	ajexp.setBeanFactory(this.beanFactory);
	return ajexp;
}

AbstractAspectJAdvisorFactoryç±»
protected static AspectJAnnotation<?> findAspectJAnnotationOnMethod(Method method) {
	Class<?>[] classesToLookFor = new Class<?>[] {
			Before.class, Around.class, After.class, AfterReturning.class, AfterThrowing.class, Pointcut.class};
	// åŒ¹é…æ–¹æ³•çš„Adviceç±»å‹ï¼šBefore.class, Around.class, After.class, AfterReturning.class, AfterThrowing.class, Pointcut.class
	// åŒ¹é…å³è¿”å›
	for (Class<?> c : classesToLookFor) {
		AspectJAnnotation<?> foundAnnotation = findAnnotation(method, (Class<Annotation>) c);
		if (foundAnnotation != null) {
			return foundAnnotation;
		}
	}
	return null;
}
----

ç”ŸæˆPointCutåï¼Œä»£ç å›åˆ°ReflectiveAspectJAdvisorFactory.getAdvisor()æ–¹æ³•çš„æ„é€ `InstantiationModelAwarePointcutAdvisorImpl`å®ä¾‹éƒ¨åˆ†ï¼ŒæŸ¥çœ‹å…¶æ„é€ æ–¹æ³•
image::https://raw.githubusercontent.com/yaoyuanyy/MarkdownPhotos/master/img/20201029210209.png[20201029210209]

å¯ä»¥çœ‹åˆ°ï¼Œ`InstantiationModelAwarePointcutAdvisorImpl`ç±»åŒ…å«`AspectJExpressionPointcut`ç±»å‹çš„pointcutåå±æ€§ï¼ŒadviceNameï¼ŒaspectJAdviceMethodåˆ‡é¢æ–¹æ³•ç­‰å±æ€§ã€‚åŒæ—¶ä¹Ÿä¼šæ ¹æ®adviceçš„typeç”Ÿæˆå¯¹åº”çš„xxxAdviceå¯¹è±¡ã€‚çœ‹æœ€åä¸€è¡Œ`instantiatedAdvice`çš„è§£æä»£ç 
----
private Advice instantiateAdvice(AspectJExpressionPointcut pcut) {
	return this.aspectJAdvisorFactory.getAdvice(this.aspectJAdviceMethod, pcut,
			this.aspectInstanceFactory, this.declarationOrder, this.aspectName);
}
	
public Advice getAdvice(Method candidateAdviceMethod, AspectJExpressionPointcut expressionPointcut,
    	MetadataAwareAspectInstanceFactory aspectInstanceFactory, int declarationOrder, String aspectName) {
    
    Class<?> candidateAspectClass = aspectInstanceFactory.getAspectMetadata().getAspectClass(); 
    AspectJAnnotation<?> aspectJAnnotation =
    		AbstractAspectJAdvisorFactory.findAspectJAnnotationOnMethod(candidateAdviceMethod);
    
    AbstractAspectJAdvice springAdvice;
    switch (aspectJAnnotation.getAnnotationType()) {
    	case AtBefore:
    		springAdvice = new AspectJMethodBeforeAdvice(
    				candidateAdviceMethod, expressionPointcut, aspectInstanceFactory);
    		break;
    	case AtAfter:
    		springAdvice = new AspectJAfterAdvice(
    				candidateAdviceMethod, expressionPointcut, aspectInstanceFactory);
    		break;
    	case AtAfterReturning:
    		springAdvice = new AspectJAfterReturningAdvice(
    				candidateAdviceMethod, expressionPointcut, aspectInstanceFactory);
    		AfterReturning afterReturningAnnotation = (AfterReturning) aspectJAnnotation.getAnnotation();
    		if (StringUtils.hasText(afterReturningAnnotation.returning())) {
    			springAdvice.setReturningName(afterReturningAnnotation.returning());
    		}
    		break;
    	case AtAfterThrowing:
    		springAdvice = new AspectJAfterThrowingAdvice(
    				candidateAdviceMethod, expressionPointcut, aspectInstanceFactory);
    		AfterThrowing afterThrowingAnnotation = (AfterThrowing) aspectJAnnotation.getAnnotation();
    		if (StringUtils.hasText(afterThrowingAnnotation.throwing())) {
    			springAdvice.setThrowingName(afterThrowingAnnotation.throwing());
    		}
    		break;
    	case AtAround:
    		springAdvice = new AspectJAroundAdvice(
    				candidateAdviceMethod, expressionPointcut, aspectInstanceFactory);
    		break;
    	case AtPointcut:
    		if (logger.isDebugEnabled()) {
    			logger.debug("Processing pointcut '" + candidateAdviceMethod.getName() + "'");
    		}
    		return null;
    	default:
    		Â·Â·Â·
    }
    
    // Now to configure the advice...
    springAdvice.setAspectName(aspectName);
    springAdvice.setDeclarationOrder(declarationOrder);
    String[] argNames = this.parameterNameDiscoverer.getParameterNames(candidateAdviceMethod);
    if (argNames != null) {
    	springAdvice.setArgumentNamesFromStringArray(argNames);
    }
    springAdvice.calculateArgumentBindings();
    return springAdvice;
}
----
æ•´ä¸ªæ–¹æ³•å°±æ˜¯ä¸ºäº†è·å–Adviceï¼Œæ ¹æ®åˆ‡é¢æ–¹æ³•(å³`TimeFeeAspect.doTimeFeeIntercepter`)ä¸Šçš„adviceæ³¨è§£typeè¿”å›å¯¹åº”çš„xxxxAdviceå®ä¾‹ã€‚è¿™é‡Œ`doTimeFeeIntercepter`æ–¹æ³•ä¸Šæ³¨è§£äº†`@Before advice`ï¼Œæ‰€ä»¥æˆ‘ä»¬å¾—åˆ°æ˜¯`AspectJMethodBeforeAdvice`å¯¹è±¡ã€‚`AspectJMethodBeforeAdvice`åŒ…å«`advice method`, `pointcut`, `aspect class name`ã€‚`AspectJMethodBeforeAdvice`ç›¸å½“äº`interceptor`ã€‚å½“ç”Ÿæˆproxyä»£ç†ç±»æ—¶ï¼Œ`AspectJMethodBeforeAdvice`å°±æ˜¯proxyä»£ç†ç±»çš„interceptorï¼Œproxyçš„åˆ‡å…¥çš„æ–¹æ³•å°±æ˜¯`AspectJMethodBeforeAdvice`çš„`advice method`ï¼Œå³TimeFeeAspect.doTimeFeeIntercepteræ–¹æ³•ã€‚è¿™æ ·ï¼Œå°±æŠŠç›®æ ‡ç±»çš„è¢«åˆ‡å…¥æ–¹æ³•å’Œaspectçš„æƒ³åˆ‡å…¥çš„æ–¹æ³•å…³è”èµ·æ¥äº†ã€‚æ‰€ä»¥æ¯æ¬¡ç¨‹åºèµ°åˆ°ç›®æ ‡ç±»çš„è¢«åˆ‡å…¥æ–¹æ³•æ—¶ï¼Œéƒ½ä¼šå…ˆèµ°aspectçš„æƒ³åˆ‡å…¥çš„æ–¹æ³•ã€‚

è¿™æ ·`InstantiationModelAwarePointcutAdvisorImpl`å¯¹è±¡å°±newå‡ºæ¥äº†ã€‚åŒ…å«å±æ€§å¦‚ä¸‹å›¾
image::https://raw.githubusercontent.com/yaoyuanyy/MarkdownPhotos/master/img/20201029210402.png[20201029210402]
æ‰€ä»¥ï¼Œå¯¹å¤–æš´éœ²çš„advisorå…¶å®å°±æ˜¯`InstantiationModelAwarePointcutAdvisorImpl`å¯¹è±¡ï¼Œå½“ç”Ÿæˆproxyä»£ç†ç±»çš„æ—¶å€™ä¼ è¿›å»çš„advisorä¹Ÿå°±æ˜¯`InstantiationModelAwarePointcutAdvisorImpl`å¯¹è±¡äº†ã€‚å½“æˆ‘ä»¬è®²è§£ https://yaoyuanyy.github.io/2019/05/28/%E7%BB%86%E8%8A%82%E6%8A%A0%E5%87%BA%E8%A1%80%20-%20spring%20boot%20aop%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E8%A7%A3%E6%9E%90%E4%B9%8B%E9%98%B6%E6%AE%B5%E4%B8%89[spring boot aopè¿‡ç¨‹è§£æä¹‹é˜¶æ®µä¸‰ï¼šç”ŸæˆProxyä»£ç†ç±»] æ—¶æ¥ç€è¯´è¿™é‡Œ

åˆ°è¿™,<font color=green>Advice classè·å–åˆ°äº†ï¼ŒAdviceçš„PointCutä¹Ÿæ‹¿åˆ°äº†ï¼Œä½†æ˜¯PointCutè‡ªèº«çš„è¡¨è¾¾å¼(Expression)å€¼è¿˜æ²¡æœ‰æ‹¿åˆ°ã€‚</font>æ¥ç€èµ°ä»£ç 

å›åˆ°`postProcessBeforeInstantiation()`æ–¹æ³•ï¼Œç”±äºæˆ‘ä»¬æ‰¾åˆ°äº†Advisorï¼Œæ‰€ä»¥shouldSkip(beanClass, beanName)è¿”å›falseï¼Œé€»è¾‘å¾€ä¸‹èµ°ã€‚åˆç”±äº`getCustomTargetSource(beanClass, beanName)`è¿”å›nullï¼Œæ‰€ä»¥è¿™æ­¥æ²¡æœ‰ç”Ÿæˆå…¥å‚beanNameæˆ–beanClassçš„ä»£ç†
image::https://raw.githubusercontent.com/yaoyuanyy/MarkdownPhotos/master/img/20201029210446.png[20201029210446]

è¿™æ ·ï¼ŒpostProcessBeforeInstantiatioin()æ–¹æ³•çš„é€»è¾‘å°±èµ°å®Œäº†ã€‚ä½†æ˜¯beanNameæˆ–beanClassè¿˜æœ‰ä¸€æ¬¡ç”Ÿæˆä»£ç†ç±»çš„æœºä¼šï¼Œå°±æ˜¯`postProcessAfterInitialization()`æ–¹æ³•æä¾›çš„

=== postProcessAfterInitialization()

æˆ‘ä»¬åœ¨æ–¹æ³•å¼€å§‹å¤„æ‰“ä¸ªæ–­ç‚¹ï¼ŒF9 debugæ”¾å¼€ï¼Œæ–­ç‚¹è¿›å…¥postProcessAfterInitialization()æ–¹æ³•
image::https://raw.githubusercontent.com/yaoyuanyy/MarkdownPhotos/master/img/20201029210536.png[20201029210536]
å¯ä»¥çœ‹åˆ°ï¼šwrapIfNecessaryæ–¹æ³•æ˜¯æ ¸å¿ƒï¼ŒæŸ¥çœ‹å…¶å†…éƒ¨ä»£ç 
----
protected Object wrapIfNecessary(Object bean, String beanName, Object cacheKey) {
	if (beanName != null && this.targetSourcedBeans.contains(beanName)) {
		return bean;
	}
	if (Boolean.FALSE.equals(this.advisedBeans.get(cacheKey))) {
		return bean;
	}
	if (isInfrastructureClass(bean.getClass()) || shouldSkip(bean.getClass(), beanName)) {
		this.advisedBeans.put(cacheKey, Boolean.FALSE);
		return bean;
	}

	// Create proxy if we have advice.
	Object[] specificInterceptors = getAdvicesAndAdvisorsForBean(bean.getClass(), beanName, null);
	if (specificInterceptors != DO_NOT_PROXY) {
		this.advisedBeans.put(cacheKey, Boolean.TRUE);
		Object proxy = createProxy(
				bean.getClass(), beanName, specificInterceptors, new SingletonTargetSource(bean));
		this.proxyTypes.put(cacheKey, proxy.getClass());
		return proxy;
	}

	this.advisedBeans.put(cacheKey, Boolean.FALSE);
	return bean;
}
----
å¯ä»¥çœ‹åˆ°ï¼Œæ–¹æ³•ä¸ŠåŠéƒ¨åˆ†ä¸postProcessBeforeInstantiation()æ–¹æ³•ç›¸åŒï¼Œåˆšæ‰çš„åˆ†æå°±æ˜¯shouldSkip(bean.getClass(), beanName)æ–¹æ³•ï¼Œæ‰€ä»¥æˆ‘ä»¬ç›´æ¥çœ‹`getAdvicesAndAdvisorsForBean(bean.getClass(), beanName, null)`ã€‚è¿™ä¸ªæ–¹æ³•è·å–Advisorï¼Œçœ‹å…¶å†…éƒ¨é€»è¾‘
----
protected Object[] getAdvicesAndAdvisorsForBean(Class<?> beanClass, String beanName, TargetSource targetSource) {
	List<Advisor> advisors = findEligibleAdvisors(beanClass, beanName);
	return advisors.toArray();
}
	
protected List<Advisor> findEligibleAdvisors(Class<?> beanClass, String beanName) {
    // è·å–Advisorå€™é€‰è€…
	List<Advisor> candidateAdvisors = findCandidateAdvisors();
	List<Advisor> eligibleAdvisors = findAdvisorsThatCanApply(candidateAdvisors, beanClass, beanName);
	extendAdvisors(eligibleAdvisors);
	return eligibleAdvisors;
}
----
findEligibleAdvisors()æ–¹æ³•é¦–å…ˆè·å–Advisorå€™é€‰è€…(findCandidateAdvisors()çš„é€»è¾‘åœ¨postProcessBeforeInstantiation()æ–¹æ³•åˆ†ææ—¶å·²ç»è¯´è¿‡)ï¼Œç„¶åé€šè¿‡findAdvisorsThatCanApply()æ–¹æ³•<font color=green>æ£€éªŒè¿™äº›Advisorå€™é€‰è€…å¯¹beanClassæ¥è¯´æ˜¯å¦æ˜¯åˆæ ¼çš„Advisor</font>ã€‚è¿™é‡Œå°±å¾ˆå…³é”®äº†ï¼Œæˆ‘ä»¬çœ‹å…¶å†…éƒ¨ä»£ç 
----
AopUtils ç±»
protected List<Advisor> findAdvisorsThatCanApply( List<Advisor> candidateAdvisors, Class<?> beanClass, String beanName) {
    return AopUtils.findAdvisorsThatCanApply(candidateAdvisors, beanClass);
}

public static List<Advisor> findAdvisorsThatCanApply(List<Advisor> candidateAdvisors, Class<?> clazz) {
	List<Advisor> eligibleAdvisors = new LinkedList<Advisor>();
	Â·Â·Â·
	boolean hasIntroductions = !eligibleAdvisors.isEmpty();
	for (Advisor candidate : candidateAdvisors) {
		if (canApply(candidate, clazz, hasIntroductions)) {
			eligibleAdvisors.add(candidate);
		}
	}
	return eligibleAdvisors;
}
----
æ–¹æ³•é‡ç‚¹æ˜¯æ¡ä»¶åˆ¤æ–­ã€‚è¿™é‡Œåªåˆ—å‡ºéƒ¨åˆ†ä»£ç ï¼Œå…¶å®æ–¹æ³•å°†å€™é€‰è€…Advisoråˆ†ä¸ºä¸¤æ‹¨ï¼Œä¸€æ‹¨æ˜¯IntroductionAdvisorï¼Œç„¶åæ¡ä»¶åˆ¤æ–­canApply(candidate, clazz)ï¼›å¦ä¸€æ‹¨æ˜¯å…¶ä»–Advisorï¼Œç„¶åæ¡ä»¶åˆ¤æ–­canApply(candidate, clazz, hasIntroductions)ï¼Œæˆ‘ä»¬debugæ—¶èµ°çš„åä¸€ä¸ªæ¡ä»¶åˆ¤æ–­æ–¹æ³•é€»è¾‘ï¼Œçœ‹å…¶å†…éƒ¨ä»£ç é€»è¾‘
----
AopUtils ç±»
public static boolean canApply(Advisor advisor, Class<?> targetClass, boolean hasIntroductions) {
	if (advisor instanceof PointcutAdvisor) {
		PointcutAdvisor pca = (PointcutAdvisor) advisor;
		return canApply(pca.getPointcut(), targetClass, hasIntroductions);
	}
}

AopUtils ç±»
public static boolean canApply(Pointcut pc, Class<?> targetClass, boolean hasIntroductions) {
         // ä½¿ç”¨PointcutåŒ¹é…targetClass,æ­¤æ—¶çš„Pointcut.pointcutExpressionèµ‹å€¼å°±éšè—åœ¨pc.getClassFilter()ä¸­
	if (!pc.getClassFilter().matches(targetClass)) {
		return false;
	}

	MethodMatcher methodMatcher = pc.getMethodMatcher();
	if (methodMatcher == MethodMatcher.TRUE) {
		// No need to iterate the methods if we're matching any method anyway...
		return true;
	}

	IntroductionAwareMethodMatcher introductionAwareMethodMatcher = null;
	if (methodMatcher instanceof IntroductionAwareMethodMatcher) {
		introductionAwareMethodMatcher = (IntroductionAwareMethodMatcher) methodMatcher;
	}

        //(1)
	Set<Class<?>> classes = new LinkedHashSet<Class<?>>(ClassUtils.getAllInterfacesForClassAsSet(targetClass));
	classes.add(targetClass);
	for (Class<?> clazz : classes) {
		Method[] methods = ReflectionUtils.getAllDeclaredMethods(clazz);
		for (Method method : methods) {
			if ((introductionAwareMethodMatcher != null &&
					introductionAwareMethodMatcher.matches(method, targetClass, hasIntroductions)) ||
					methodMatcher.matches(method, targetClass)) {//(2)
				return true;
			}
		}
	}

	return false;
}
----
æ•´ä¸ªæ–¹æ³•éƒ½åœ¨åˆ¤æ–­targerClassæ˜¯å¦åŒ¹é…è¿™ä¸ªpointcutï¼Œç”±äºæ­¤æ—¶çš„pointcut.pointcutExpressionè¿˜æ²¡æœ‰èµ‹å€¼å‘¢ï¼Œæ‰€ä»¥åœ¨åˆ¤æ–­åŒ¹é…ä¹‹å‰ï¼Œéœ€è¦<font color=green>pointcut.pointcutExpressionèµ‹å€¼</font>ï¼Œæ‰€ä»¥æ•´ä¸ªAopUtis.canApplyåˆ†ä¸ºä¸¤éƒ¨åˆ†ï¼š
1. ç»™pointcut.pointcutExpressionèµ‹å€¼
2. targerClassåŒ¹é…pointcutæ£€éªŒ
è€Œç¬¬ä¸€éƒ¨åˆ†çš„èµ‹å€¼åœ¨pc.getClassFilter()é‡Œï¼Œçœ‹æ–¹æ³•ä»£ç 

----
AspectJExpressionPointcutç±»
public ClassFilter getClassFilter() {
	checkReadyToMatch();
	return this;
}
	
private void checkReadyToMatch() 
	if (this.pointcutExpression == null) {
		this.pointcutClassLoader = determinePointcutClassLoader();
		this.pointcutExpression = buildPointcutExpression(this.pointcutClassLoader);
	}
}

private PointcutExpression buildPointcutExpression(ClassLoader classLoader) {
	PointcutParser parser = initializePointcutParser(classLoader);
	return parser.parsePointcutExpression(replaceBooleanOperators(getExpression()),
			this.pointcutDeclarationScope, pointcutParameters);
}

PointcutParserç±»
public PointcutExpression parsePointcutExpression(String expression, Class<?> inScope, PointcutParameter[] formalParameters)  { 
	Pointcut pc = resolvePointcutExpression(expression, inScope, formalParameters);
	PointcutExpressionImpl pcExpr = new PointcutExpressionImpl(pc, expression, formalParameters, getWorld());
	return pcExpr;
}

protected Pointcut resolvePointcutExpression(String expression, Class<?> inScope, PointcutParameter[] formalParameters) {
	PatternParser parser = new PatternParser(expression);
	parser.setPointcutDesignatorHandlers(pointcutDesignators, world);
	Pointcut pc = parser.parsePointcut();
	IScope resolutionScope = buildResolutionScope((inScope == null ? Object.class : inScope), formalParameters);
	pc = pc.resolve(resolutionScope);
	return pc;
}
----
ä»¥ä¸Šä»£ç çš„æ ¸å¿ƒé€»è¾‘å°±æ˜¯ç»™AspectJExpressionPointcut.PointcutExpressionèµ‹å€¼ï¼Œè¿™ä¸ªå°±æ˜¯å¼€ç¯‡æ—¶çš„ä¾‹å­ä»£ç ï¼š@Pointcut("execution(* com.yy..rest..*(..))")ã€‚èµ‹å€¼æ“ä½œæ˜¯é€šè¿‡PointcutParserã€PatternParserå’ŒPointcutæ¥å®Œæˆçš„ã€‚å…·ä½“çš„èµ‹å€¼è¿‡ç¨‹å…¥å£ä¸ºpc = pc.resolve(resolutionScope)ã€‚resolveæ–¹æ³•è°ƒç”¨æ ˆï¼š
----
Pointcut.resolve()
-this.resolveBindings()
--searchType.findPointcut(name)
searchTypeå°±æ˜¯TimeFeeAspectï¼Œnameå°±æ˜¯cutæ–¹æ³•å
       ... ç»è¿‡getPointcuts().iteratorå¾ªç¯ ...
---Java15ReflectionBasedReferenceTypeDelegate.getDeclaredPointcuts()
----AjType.getDeclaredPointcuts()
-----Method[] methods = clazz.getDeclaredMethods(ï¼‰
----
clazzå°±æ˜¯TimeFeeAspect,<font color=green>å¾ªç¯methodsï¼Œåˆ¤æ–­methodæ˜¯å¦æœ‰@Pointcutæ³¨è§£ï¼šPointcut pcAnn = method.getAnnotation(Pointcut.class);
æ‹¿åˆ°pcAnn.value()ã€‚æ„é€ æˆä¸€ä¸ªPointcutï¼Œå†æ„é€ æˆä¸€ä¸ªPointcutExpressionImplï¼Œå†æ„é€ æˆä¸€ä¸ªPointcutImplã€‚æœ€åAspectJExpressionPointcut.PointcutExpressionè¢«èµ‹å€¼äº†</font>ã€‚åˆ‡å…¥ç‚¹çš„è¡¨è¾¾å¼å·²ç»æœ‰äº†ï¼Œæ¥ä¸‹æ¥è¦åšçš„è‡ªç„¶æ˜¯ä½¿ç”¨è¡¨è¾¾å¼æ¥éªŒè¯ç›®æ ‡äº†ã€‚è¿™éƒ¨åˆ†å³æ˜¯`AopUtils.canApply()`æ–¹æ³•çš„ç¬¬äºŒéƒ¨åˆ†çš„é€»è¾‘ã€‚

ä¸‹é¢çœ‹`AopUtils.canApply()`æ–¹æ³•çš„ç¬¬äºŒéƒ¨åˆ†ï¼štargerClassåŒ¹é…pointcutæ£€éªŒï¼Œé¦–å…ˆçœ‹`pc.getClassFilter().matches(targetClass)`å¦‚æœåŒ¹é…ï¼Œä»£ç å¾€ä¸‹èµ°ï¼›å¦‚æœä¸åŒ¹é…ï¼Œç›´æ¥è¿”å›falseã€‚æ¥ç€èµ°(2)å¤„ä»£ç ï¼Œå³è·å–targerClassçš„æ‰€æœ‰æ¥å£å’Œçˆ¶ç±»ï¼Œéå†æ¯ä¸ªç±»çš„æ¯ä¸ªæ–¹æ³•ï¼Œä½¿ç”¨Pointcutçš„expressionå»matchæ¯ä¸ªæ–¹æ³•ï¼Œä¸€æ—¦æœ‰åŒ¹é…ä¸Šï¼Œè¿”å›trueï¼Œé€€å‡ºéå†ã€‚æ‰€ä»¥åŒ¹é…çš„é€»è¾‘å°±æ˜¯é‡ç‚¹äº†ã€‚è¿™é‡Œåˆ—ä¸‹å…³é”®çš„ä»£ç æ®µ
----
AspectJExpressionPointcutç±»
public boolean matches(Method method, Class<?> targetClass, boolean beanHasIntroductions) {
	Method targetMethod = AopUtils.getMostSpecificMethod(method, targetClass);
	ShadowMatch shadowMatch = getShadowMatch(targetMethod, method);  //å…³é”®ä»£ç 
	if (shadowMatch.alwaysMatches()) {
	  return true;
	}
	else if (shadowMatch.neverMatches()) {
	  return false;
	}
}

// å¯ä»¥çœ‹åˆ°è¿™ä¸ªæ–¹æ³•ä¸­ä½¿ç”¨äº†åŒé‡æ£€æŸ¥æœºåˆ¶(double check)ï¼Œdouble checkç»“åˆsynchronizedå¯ä»¥æœ‰æ•ˆçš„
// é¿å…é”çš„ç«äº‰ï¼Œè¿™ä¸ªç»„åˆæˆ‘ä»¬å¯ä»¥åœ¨å¾ˆå¤šåœ°æ–¹ä½¿ç”¨ï¼Œæƒ³æƒ³åœ¨ä½ çš„é¡¹ç›®ä¸­ä½¿ç”¨å®ƒï¼Œå¾ˆæ£’ï¼Œé¢è¯•ä¹Ÿæ˜¯é«˜é¢‘çŸ¥è¯†ç‚¹
private ShadowMatch getShadowMatch(Method targetMethod, Method originalMethod) {
  // Avoid lock contention for known Methods through concurrent access...
  ShadowMatch shadowMatch = this.shadowMatchCache.get(targetMethod);
  if (shadowMatch == null) {
    synchronized (this.shadowMatchCache) {
        shadowMatch = this.shadowMatchCache.get(targetMethod);
        if (shadowMatch == null) {
					// pointcutExpressionå¯¹è±¡åŒ…å«KindedpPointcutç±»å‹çš„å±æ€§pointcut "execution(* com.yy..rest..*(..))"
					// KindedpPointcutåŒ…å«SignaturePatternç±»å‹çš„å±æ€§signature "* com.yy..rest..*(..)"
          shadowMatch = this.pointcutExpression.matchesMethodExecution(methodToMatch);  //å…³é”®ä»£ç 
        }
    }
  }
}

PointcutExpressionImplç±»
private ShadowMatchImpl getShadowMatch(Shadow forShadow) {
	org.aspectj.util.FuzzyBoolean match = pointcut.match(forShadow); //å…³é”®ä»£ç 
	Test residueTest = Literal.TRUE;
	ExposedState state = getExposedState();
	if (match.maybeTrue()) {
		residueTest = pointcut.findResidue(forShadow, state);
	}
	ShadowMatchImpl sm = new ShadowMatchImpl(match, residueTest, state, parameters);
	sm.setMatchingContext(this.matchContext);
	return sm;
}

WildTypePatternç±»ï¼ŒçœŸæ­£çš„éªŒè¯é€»è¾‘å°±åœ¨è¿™ä¸ªç±»ã€‚
protected boolean matchesExactly(ResolvedType type, ResolvedType annotatedType) {
	String targetTypeName = type.getName();

	// System.err.println("match: " + targetTypeName + ", " + knownMatches); //Arrays.asList(importedPrefixes));
	// Ensure the annotation pattern is resolved
	annotationPattern.resolve(type.getWorld());

        // å››ä¸ªæ–¹æ³•çš„&&ç»“æœ
	return matchesExactlyByName(targetTypeName, type.isAnonymous(), type.isNested()) && matchesParameters(type, STATIC)
			&& matchesBounds(type, STATIC)
			&& annotationPattern.matches(annotatedType, type.temporaryAnnotationTypes).alwaysTrue();
}
----
- `matchesExactlyByName(..)`æ¯”è¾ƒå…¨é™å®šç±»åæ˜¯å¦åŒ¹é…ã€‚ä¼šæŠŠpointcutçš„expressionå’Œç›®æ ‡ç±»çš„å…¨é™å®šåå˜ä¸º.åˆ†éš”çš„æ•°ç»„ï¼Œå¯¹åº”ä¸‹æ ‡å€¼ä¾æ¬¡æ¯”è¾ƒã€‚åƒè¿™æ ·ï¼š`pattern[pi].matches(target[ti])`ã€‚
- `matchesParameters(..)`æ¯”è¾ƒæ–¹æ³•çš„å‚æ•°æ˜¯å¦åŒ¹é…
- `matchesBounds(..)`æ¯”è¾ƒæ–¹æ³•æˆ–å‚æ•°å¸¦?æ—¶æ˜¯å¦åŒ¹é…
- `annotationPattern(..)`æ¯”è¾ƒæ–¹æ³•æˆ–å‚æ•°çš„æ³¨è§£æ˜¯å¦åŒ¹é…
å½“ç„¶ï¼Œæ ¹æ®&&çŸ­è·¯åŸåˆ™ï¼Œå‰é¢çš„æ–¹æ³•è¿”å›falseæ—¶ï¼Œåé¢çš„æ–¹æ³•ä¸ç”¨èµ°äº†ï¼Œç›´æ¥è¿”å›ç»“æœã€‚æœ¬ä¾‹debugæ—¶ï¼Œpointcutä¸º"execution(* com.yy..rest..*(..))ï¼Œç›®æ ‡targetç±»ä¸ºcom.yy.custom_spring.custom5.CustomInstantiationAwarePostProcessorAdapterï¼Œä¸¤è€…æ¯”è¾ƒï¼ŒåŒ…åä¸ä¸€æ ·ï¼Œæ‰€ä»¥ä¸åŒ¹é…ï¼Œè¿”å›false

å¦å¤–ï¼ŒtargerClassæ˜¯å¦åŒ¹é…pointcutçš„è¿‡ç¨‹æˆ‘ä»¬ä¹Ÿå¯ä»¥é€šè¿‡debugçš„è°ƒç”¨æ ˆæ¥è§‚å¯Ÿè°ƒç”¨å…³ç³»ï¼Œå¦‚ä¸‹å›¾ã€‚è¿™æ ·ï¼Œä½ è‡ªå·±debugèµ°ä»£ç çš„æ—¶å€™ä½“ä¼šçš„æ›´ç›´æ¥

image::https://raw.githubusercontent.com/yaoyuanyy/MarkdownPhotos/master/img/20201029210636.png[20201029210636]

åˆ°è¿™é‡Œï¼Œspring boot aopè¿‡ç¨‹è§£æä¹‹é˜¶æ®µäºŒåˆ¤æ–­beanNameæˆ–beanClassæ˜¯å¦ç”ŸæˆProxyä»£ç†ç±»å°±èµ°å®Œäº†ã€‚æ²¡æœ‰é¢é¢ä¿±åˆ°ï¼Œä½†å…³é”®åœ°æ–¹éƒ½æœ‰æåˆ°ã€‚å¦‚æœ‰ä»»ä½•ç–‘é—®å’Œé—®é¢˜ï¼Œæ¬¢è¿ä¸€èµ·äº¤æµè¿›æ­¥ï¼Œå¯ä»¥ç•™è¨€æˆ–é‚®ç®± skyler_11@163.com yaoyihao1@gmail.com

=== é—®é¢˜å›ç­”

- é’ˆå¯¹æ–‡ç« å¼€å¤´çš„é—®é¢˜æˆ‘ä»¬å¯ä»¥å›ç­”ä¸‹äº†ï¼š

é—®é¢˜ï¼š
----
1. spring aopæ˜¯å¦‚æœè·å–å’Œè§£æAspect(advisor)åˆ‡é¢ç±»çš„
2. spring aopæ˜¯å¦‚æœè·å–å’Œè§£æ@Pointcutæ³¨è§£çš„
3. @Pointcutæ³¨è§£çš„execution(expression)å­˜æ”¾åœ¨å“ªä¸ªå¯¹è±¡ï¼Œä»€ä¹ˆæ—¶å€™è¢«ä½¿ç”¨
4. @Beforeæ³¨è§£spring aopæ˜¯å¦‚æœè·å–å’Œè§£æçš„ï¼Œspring aopå¦‚ä½•æ‰¾åˆ°@Beforeå¯¹åº”çš„Pointcutï¼Ÿ
5. ä»€ä¹ˆæ—¶å€™ä»€ä¹ˆä½ç½®åœ¨çœŸå®å¯¹è±¡æ–¹æ³•å‰ååŠ ä¸Šä»£ç†é€»è¾‘çš„
----

ç­”æ¡ˆï¼š

----
1. springæ˜¯ä»ä¸¤ä¸ªæ–¹é¢è·å–Aspect(advisor)åˆ‡é¢ç±»çš„
ä¸€æ–¹é¢ï¼šString[] advisorNames = BeanFactoryUtils.beanNamesForTypeIncludingAncestors(this.beanFactory, Advisor.class, true, false);
å¦ä¸€æ–¹é¢ï¼šString[] beanNames = BeanFactoryUtils.beanNamesForTypeIncludingAncestors(this.beanFactory, Object.class, true, false);ç„¶åéå†beanNamesï¼Œæ‰¾åˆ°å¯¹åº”çš„beanï¼Œçœ‹çœ‹è¿™ä¸ªbeanæ˜¯å¦æœ‰@Aspectæ³¨è§£ï¼Œæœ‰å°±æ˜¯Aspect(advisor)


2. springæ˜¯æ‰¾åˆ°å¹¶è§£æAspectç±»ä¸­Adviceæ–¹æ³•çš„å‚æ•°ï¼Œå¦‚@Before("cut()") public void doTimeFeeIntercepteræ–¹æ³•ã€‚å…·ä½“çš„è§£æä½ç½®æ˜¯AspectJExpressionPointcut=ReflectiveAspectJAdvisorFactory.getPointcut()æ–¹æ³•ï¼Œè¿™æ—¶çš„AspectJExpressionPointcutåªæœ‰å€¼cut(),è¡¨è¾¾å¼è¿˜æ²¡æœ‰èµ‹å€¼å‘¢ã€‚ç„¶åå†æ ¹æ®cut()é‡æ–°è§£æAspectç±»ï¼Œæ‰¾åˆ°Expressionå¹¶èµ‹å€¼ç»™AspectJExpressionPointcutï¼Œè¿™æ­¥æ˜¯åœ¨Pointcut.resolve()ä¸­å®Œæˆçš„

3. execution(expression)å­˜æ”¾åœ¨KindedPointcutå¯¹è±¡ä¸­ï¼Œåœ¨éªŒè¯targerClassæ˜¯å¦åŒ¹é…æ—¶è¢«ä½¿ç”¨
----

å¦‚æœ‰ä»»ä½•ç–‘é—®å’Œé—®é¢˜ï¼Œæ¬¢è¿ä¸€èµ·äº¤æµè¿›æ­¥ï¼Œå¯ä»¥ç•™è¨€æˆ–é‚®ç®± skyler_11@163.com yaoyihao1@gmail.com