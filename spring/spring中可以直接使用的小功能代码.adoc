= springä¸­å¯ä»¥ç›´æ¥ä½¿ç”¨çš„ä»£ç å—
:toc: left
:toc-title: ç›®å½•
:tip-caption: ğŸ’¡
:note-caption: â„¹ï¸
:important-caption: â—
:caution-caption: ğŸ”¥
:warning-caption: âš ï¸
// :tip-caption: :bulb:
// :note-caption: :information_source:
// :important-caption: :heavy_exclamation_mark:	
// :caution-caption: :fire:
// :warning-caption: :warning:
:icons: font

Doc writer yaoyihao1@gmail.com

é˜…è¯»ï¼Œspring, springbootæ—¶èƒ½å‘ç°å¾ˆå¤šçš„å¾ˆå¥½çš„å°åŠŸèƒ½ç‚¹ï¼Œå¦‚ï¼ŒåŠ è½½æ–‡ä»¶ã€è§£æç±»çš„æ–¹æ³•æ³¨è§£ã€é€šè¿‡classç”Ÿæˆbeanç­‰ç­‰ï¼Œæœ¬æ–‡å°±æ¥æ•´ç†ä¸‹è¿™äº›å°åŠŸèƒ½

== åŠ è½½META-INF/spring.factory
todo

----
List<String> configurations = SpringFactoriesLoader.loadFactoryNames(
		EnableAutoConfiguration.class, getBeanClassLoader());
Assert.notEmpty(configurations, "No auto configuration classes found in META-INF/spring.factories. If you " + "are using a custom packaging, make sure that file is correct.");
return configurations;
----

== åŠ è½½classPath:application.yml
----
Properties properties = PropertiesLoaderUtils.loadProperties(new ClassPathResource("application.yml"))
String value = properties.getProperty(String key);
----
== åŠ è½½jar:file:/Users/xx/spring-xx.jar!/META-INF/spring.factories
----
åŠ è½½jar:file:/Users/skyler/.m2/repository/org/springframework/boot/spring-boot/1.5.10.RELEASE/spring-boot-1.5.10.RELEASE.jar!/META-INF/spring.factories
æŠŠkey=value,value,valueè½¬æˆlist<value>

Properties properties = PropertiesLoaderUtils.loadProperties(new UrlResource(url));
String factoryClassNames = properties.getProperty(factoryClassName);
List<String> result = new ArrayList<String>();
result.addAll(Arrays.asList(StringUtils.commaDelimitedListToStringArray(factoryClassNames)));

----

== é€šè¿‡classNameç”Ÿæˆclass bean
SpringFactoriesLoader class
----
private static <T> T instantiateFactory(String instanceClassName, Class<T> factoryClass, ClassLoader classLoader) {
	try {
		Class<?> instanceClass = ClassUtils.forName(instanceClassName, classLoader);
		if (!factoryClass.isAssignableFrom(instanceClass)) {
			throw new IllegalArgumentException(
					"Class [" + instanceClassName + "] is not assignable to [" + factoryClass.getName() + "]");
		}
		Constructor<?> constructor = instanceClass.getDeclaredConstructor();
		ReflectionUtils.makeAccessible(constructor);
		return (T) constructor.newInstance();
	}
	catch (Throwable ex) {
		throw new IllegalArgumentException("Unable to instantiate factory class: " + factoryClass.getName(), ex);
	}
}
----

== è·å–ä¸€ä¸ªç±»ä¸­æ ‡æœ‰æŒ‡å®šæ³¨è§£çš„æ‰€æœ‰æ–¹æ³•
----
final List<Method> methods = new LinkedList<Method>();
ReflectionUtils.doWithMethods(aspectClass, new ReflectionUtils.MethodCallback() {
	@Override
	public void doWith(Method method) throws IllegalArgumentException {
		// Exclude pointcuts
		if (AnnotationUtils.getAnnotation(method, Pointcut.class) == null) {
			methods.add(method);
		}
	}
});
Collections.sort(methods, METHOD_COMPARATOR);
return methods;
----