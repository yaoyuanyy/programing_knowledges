= BeanFactoryPostProcessorå®¶æ—ç±»è§£æ 
:toc-title: ç›®å½•
:tip-caption: ğŸ’¡
:note-caption: â„¹ï¸
:important-caption: â—
:caution-caption: ğŸ”¥
:warning-caption: âš ï¸
// :tip-caption: :bulb:
// :note-caption: :information_source:
// :important-caption: :heavy_exclamation_mark:	
// :caution-caption: :fire:
// :warning-caption: :warning:
:icons: font

Doc writer yaoyihao1@gmail.com


== BeanFactoryPostProcessoryç®€ä»‹
é¦–å…ˆçœ‹ä¸‹ç±»çš„javadoc 
<font size=1>
* Allows for custom modification of an application context's bean definitions, adapting the bean property values of the context's underlying bean factory.
* Application contexts can auto-detect BeanFactoryPostProcessor beans in their bean definitions and apply them before any other beans get created.
* Useful for custom config files targeted at system administrators that override bean properties configured in the application context.
* See PropertyResourceConfigurer and its concrete implementations for out-of-the-box solutions that address such configuration needs.
* A BeanFactoryPostProcessor may interact with and modify bean definitions, but never bean instances. Doing so may cause premature bean instantiation, violating the container and causing unintended side-effects. If bean instance interaction is required, consider implementing BeanPostProcessor instead

</font>

![05](BeanFactoryPostProcessorå®¶æ—ç±»è§£æ/05.png)
todo


ç¿»è¯‘å¦‚ä¸‹ï¼š
<font size=1>
* å…è®¸application contextçš„bean definitionsè‡ªå®šä¹‰ä¿®æ”¹ï¼Œæ”¹å†™the contextçš„åº•å±‚bean factoryçš„beançš„å±æ€§å€¼ã€‚
* Application contextèƒ½é€šè¿‡ä»–çš„bean definitionsè‡ªåŠ¨æ£€æµ‹åˆ° BeanFactoryPostProcessor beansï¼Œå¹¶åœ¨å…¶ä»–çš„beansè¢«åˆ›å»ºå‰åº”ç”¨the beans
* è‡ªå®šä¹‰config fileså»è¦†ç›–application contexté…ç½®çš„beanå±æ€§æ˜¯æœ‰ç”¨çš„
* æŸ¥çœ‹PropertyResourceConfigurerç±»å’Œä»–çš„å…·ä½“çš„å®ç°ä¸ºè§£å†³é‚£äº›é…ç½®éœ€è¦çš„å³æ’å³ç”¨çš„æ–¹æ¡ˆ // todo æ²¡æ‡‚
* A BeanFactoryPostProcessorç”¨äºä¿®æ”¹bean definitionsï¼Œè€Œä¸æ˜¯bean instancesã€‚è¿™ä¹ˆåšå¯å¯¼è‡´beanè¿‡æ—©çš„ instantiation(å®ä¾‹åŒ–)ã€ä¾µçŠ¯å®¹å™¨å’Œå…¶ä»–æ„å¤–çš„å‰¯ä½œç”¨ã€‚å¦‚æœä½ è¦bean instanceï¼Œè¯·ä½¿ç”¨BeanPostProcessor

</font>

<font color="#FF0000">æ³¨</font>: æœ€åä¸€æ®µä¹Ÿæ˜¯<font color="green" size=3 face="å®‹ä½“"> *BeanFactoryPostProcessoryä¸BeanPostProcessoråŒºåˆ«*</font>


==
== æ–¹æ³•
ä»–çš„æ–¹æ³•åªæœ‰ä¸€ä¸ªï¼Œé€šè¿‡è¿™ä¸ªæ–¹æ³•å¯ä»¥åšåˆ°ï¼šbeanè¦†ç›–æˆ–æ·»åŠ å±æ€§ï¼Œç”šè‡³æ˜¯åˆå§‹åŒ–bean

----
/**
 * å…è®¸è¦†ç›–æˆ–æ·»åŠ å±æ€§ï¼Œç”šè‡³æ˜¯åˆå§‹åŒ–bean
 */
void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException;


----


== BeanDefinitionRegistryPostProcessorç®€ä»‹

ä»–çš„javadoc
* <font size=1>è¿™ä¸ªæ¥å£æ‰©å±•äº†æ ‡å‡†çš„BeanFactoryPostProcessor æ¥å£ï¼Œå…è®¸åœ¨æ™®é€šçš„BeanFactoryPostProcessoræ¥å£å®ç°ç±»æ‰§è¡Œä¹‹å‰æ³¨å†Œæ›´å¤šçš„BeanDefinitionã€‚ç‰¹åˆ«åœ°æ˜¯ï¼ŒBeanDefinitionRegistryPostProcessorå¯ä»¥æ³¨å†ŒBeanFactoryPostProcessorçš„BeanDefinition
</font>

æ–¹æ³•

----
/**
 * Modify the application context's internal bean definition registry after its
 * standard initialization. All regular bean definitions will have been loaded,
 * but no beans will have been instantiated yet. This allows for adding further
 * bean definitions before the next post-processing phase kicks in.
 */
void postProcessBeanDefinitionRegistry(BeanDefinitionRegistry registry) throws BeansException;

----
postProcessBeanDefinitionRegistryæ–¹æ³•å¯ä»¥ä¿®æ”¹åœ¨BeanDefinitionRegistryæ¥å£å®ç°ç±»ä¸­æ³¨å†Œçš„ä»»æ„BeanDefinitionï¼Œä¹Ÿå¯ä»¥å¢åŠ å’Œåˆ é™¤BeanDefinitionã€‚åŸå› æ˜¯è¿™ä¸ªæ–¹æ³•æ‰§è¡Œå‰æ‰€æœ‰å¸¸è§„çš„BeanDefinitionå·²ç»è¢«åŠ è½½åˆ°BeanDefinitionRegistryæ¥å£å®ç°ç±»ä¸­ï¼Œä½†è¿˜æ²¡æœ‰beanè¢«å®ä¾‹åŒ–ã€‚

å®é™…ä¸Šï¼ŒMybatisä¸­org.mybatis.spring.mapper.MapperScannerConfigurerå°±å®ç°äº†è¯¥æ–¹æ³•ï¼Œåœ¨åªæœ‰æ¥å£æ²¡æœ‰å®ç°ç±»çš„æƒ…å†µä¸‹æ‰¾åˆ°æ¥å£æ–¹æ³•ä¸sqlä¹‹é—´çš„è”ç³»ä»è€Œç”ŸæˆBeanDefinitionå¹¶æ³¨å†Œã€‚è€ŒSpring ConfigurationClassPostProcessorä¹Ÿæ˜¯ç”¨æ¥å°†æ³¨è§£@Configurationä¸­çš„ç›¸å…³ç”Ÿæˆbeançš„æ–¹æ³•æ‰€å¯¹åº”çš„BeanDefinitionè¿›è¡Œæ³¨å†Œã€‚



== PropertySourcesPlaceholderConfigurer

----
// todo

----


== BeanDefinitionRegistryPostProcessorä¸BeanFactoryPostProcessorçš„åŒºåˆ«
BeanDefinitionRegistryPostProcessorç»§æ‰¿BeanFactoryPostProcessorï¼Œé™¤äº†BeanFactoryPostProcessorçš„åŠŸèƒ½å¤–ï¼Œ<font color=green size = 4>*BeanDefinitionRegistryPostProcessorå¯ä»¥æ³¨å†ŒBeanFactoryPostProcessorçš„BeanDefinition*</font>ï¼Œè¿™ä¹Ÿæ˜¯ä»–å’ŒBeanFactoryPostProcessorçš„ä¸»è¦åŒºåˆ«


== BeanFactoryPostProcessoråŠå®ç°ç±»æ–¹æ³•è°ƒç”¨å…¥å£
è°ƒç”¨å…¥å£æ ˆ

----
AbstractApplicationContext.refresh()
-- PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors
---- BeanDefinitionRegistryPostProcessors.invokeBeanDefinitionRegistryPostProcessors
---- BeanFactoryPostProcessor.invokeBeanFactoryPostProcessors

----
æ‰€ä»¥è°ƒç”¨BeanFactoryPostProcessoræ–¹æ³•çš„å…¥å£åœ¨PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessorsæ–¹æ³•ã€‚çœ‹ä»£ç 

----
public static void invokeBeanFactoryPostProcessors(
		ConfigurableListableBeanFactory beanFactory, List<BeanFactoryPostProcessor> beanFactoryPostProcessors) {

	// Invoke BeanDefinitionRegistryPostProcessors first, if any.
	Set<String> processedBeans = new HashSet<String>();

	if (beanFactory instanceof BeanDefinitionRegistry) {
		BeanDefinitionRegistry registry = (BeanDefinitionRegistry) beanFactory;
		List<BeanFactoryPostProcessor> regularPostProcessors = new LinkedList<BeanFactoryPostProcessor>();
		List<BeanDefinitionRegistryPostProcessor> registryProcessors = new LinkedList<BeanDefinitionRegistryPostProcessor>();

		for (BeanFactoryPostProcessor postProcessor : beanFactoryPostProcessors) {
			if (postProcessor instanceof BeanDefinitionRegistryPostProcessor) {
				BeanDefinitionRegistryPostProcessor registryProcessor =
						(BeanDefinitionRegistryPostProcessor) postProcessor;
				registryProcessor.postProcessBeanDefinitionRegistry(registry);
				registryProcessors.add(registryProcessor);
			}
			else {
				regularPostProcessors.add(postProcessor);
			}
		}

		// Do not initialize FactoryBeans here: We need to leave all regular beans
		// uninitialized to let the bean factory post-processors apply to them!
		// Separate between BeanDefinitionRegistryPostProcessors that implement
		// PriorityOrdered, Ordered, and the rest.
		List<BeanDefinitionRegistryPostProcessor> currentRegistryProcessors = new ArrayList<BeanDefinitionRegistryPostProcessor>();

		// First, invoke the BeanDefinitionRegistryPostProcessors that implement PriorityOrdered.
		String[] postProcessorNames =
				beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false);
		for (String ppName : postProcessorNames) {
			if (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) {
				currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));
				processedBeans.add(ppName);
			}
		}
		sortPostProcessors(currentRegistryProcessors, beanFactory);
		registryProcessors.addAll(currentRegistryProcessors);
		invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);
		currentRegistryProcessors.clear();

		// Next, invoke the BeanDefinitionRegistryPostProcessors that implement Ordered.
		postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false);
		for (String ppName : postProcessorNames) {
			if (!processedBeans.contains(ppName) && beanFactory.isTypeMatch(ppName, Ordered.class)) {
				currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));
				processedBeans.add(ppName);
			}
		}
		sortPostProcessors(currentRegistryProcessors, beanFactory);
		registryProcessors.addAll(currentRegistryProcessors);
		invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);
		currentRegistryProcessors.clear();

		// Finally, invoke all other BeanDefinitionRegistryPostProcessors until no further ones appear.
		boolean reiterate = true;
		while (reiterate) {
			reiterate = false;
			postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false);
			for (String ppName : postProcessorNames) {
				if (!processedBeans.contains(ppName)) {
					currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));
					processedBeans.add(ppName);
					reiterate = true;
				}
			}
			sortPostProcessors(currentRegistryProcessors, beanFactory);
			registryProcessors.addAll(currentRegistryProcessors);
			invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);
			currentRegistryProcessors.clear();
		}

		// Now, invoke the postProcessBeanFactory callback of all processors handled so far.
		invokeBeanFactoryPostProcessors(registryProcessors, beanFactory);
		invokeBeanFactoryPostProcessors(regularPostProcessors, beanFactory);
	}

	else {
		// Invoke factory processors registered with the context instance.
		invokeBeanFactoryPostProcessors(beanFactoryPostProcessors, beanFactory);
	}

	// Do not initialize FactoryBeans here: We need to leave all regular beans
	// uninitialized to let the bean factory post-processors apply to them!
	String[] postProcessorNames =
			beanFactory.getBeanNamesForType(BeanFactoryPostProcessor.class, true, false);

	// Separate between BeanFactoryPostProcessors that implement PriorityOrdered,
	// Ordered, and the rest.
	List<BeanFactoryPostProcessor> priorityOrderedPostProcessors = new ArrayList<BeanFactoryPostProcessor>();
	List<String> orderedPostProcessorNames = new ArrayList<String>();
	List<String> nonOrderedPostProcessorNames = new ArrayList<String>();
	for (String ppName : postProcessorNames) {
		if (processedBeans.contains(ppName)) {
			// skip - already processed in first phase above
		}
		else if (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) {
			priorityOrderedPostProcessors.add(beanFactory.getBean(ppName, BeanFactoryPostProcessor.class));
		}
		else if (beanFactory.isTypeMatch(ppName, Ordered.class)) {
			orderedPostProcessorNames.add(ppName);
		}
		else {
			nonOrderedPostProcessorNames.add(ppName);
		}
	}

	// First, invoke the BeanFactoryPostProcessors that implement PriorityOrdered.
	sortPostProcessors(priorityOrderedPostProcessors, beanFactory);
	invokeBeanFactoryPostProcessors(priorityOrderedPostProcessors, beanFactory);

	// Next, invoke the BeanFactoryPostProcessors that implement Ordered.
	List<BeanFactoryPostProcessor> orderedPostProcessors = new ArrayList<BeanFactoryPostProcessor>();
	for (String postProcessorName : orderedPostProcessorNames) {
		orderedPostProcessors.add(beanFactory.getBean(postProcessorName, BeanFactoryPostProcessor.class));
	}
	sortPostProcessors(orderedPostProcessors, beanFactory);
	invokeBeanFactoryPostProcessors(orderedPostProcessors, beanFactory);

	// Finally, invoke all other BeanFactoryPostProcessors.
	List<BeanFactoryPostProcessor> nonOrderedPostProcessors = new ArrayList<BeanFactoryPostProcessor>();
	for (String postProcessorName : nonOrderedPostProcessorNames) {
		nonOrderedPostProcessors.add(beanFactory.getBean(postProcessorName, BeanFactoryPostProcessor.class));
	}
	invokeBeanFactoryPostProcessors(nonOrderedPostProcessors, beanFactory);

	// Clear cached merged bean definitions since the post-processors might have
	// modified the original metadata, e.g. replacing placeholders in values...
	beanFactory.clearMetadataCache();
}

----
æ–¹æ³•å¾ˆé•¿ï¼Œä½†æ˜¯é€»è¾‘æŒºç®€å•çš„ï¼Œåå¤å°±æ˜¯åšä¸€ä»¶äº‹ï¼šinvokeBeanFactoryPostProcessors(List<BeanFactoryPostProcessor>, beanFactory),åªä¸è¿‡æŒ‰ä¸€å®šçš„é¡ºåºç»´åº¦åˆ†åˆ«è°ƒç”¨çš„ï¼Œå…·ä½“çš„é¡ºåºä¸º
1. é¦–å…ˆï¼ŒAbstractApplicationContext.beanFactoryPostProcessorså±æ€§
2. å…¶æ¬¡ï¼Œå®ç°äº†PriorityOrderedæ¥å£çš„BeanDefinitionRegistryPostProcessors
3. ç„¶åï¼Œå®ç°äº†orderedæ¥å£çš„BeanDefinitionRegistryPostProcessors
4. å†ç„¶åï¼Œå…¶ä»–çš„BeanDefinitionRegistryPostProcessors
5. æœ€åï¼Œå¸¸è§„çš„BeanFactoryPostProcessors

ä»è¿™ä¸ªé¡ºåºæˆ‘ä»¬å¯ä»¥çŸ¥é“ä¸€ä¸ªçŸ¥è¯†ç‚¹:æœ¬æ–‡ä¸Šé¢çš„BeanDefinitionRegistryPostProcessorä¸BeanFactoryPostProcessorçš„åŒºåˆ«ï¼›BeanDefinitionRegistryPostProcessor.invokeBeanDefinitionRegistryPostProcessoræ–¹æ³•æ¯”BeanFactoryPostProcessor.invokeBeanFactoryPostProcessorsæ–¹æ³•å…ˆè¢«è°ƒç”¨ï¼Œ

----
# BeanDefinitionRegistryPostProcessor.class
invokeBeanDefinitionRegistryPostProcessoræ–¹æ³•å¯ä»¥è¿›ä¸€æ­¥çš„å¤„ç†Bean definition
private static void invokeBeanDefinitionRegistryPostProcessor(
		Collection<? extends BeanDefinitionRegistryPostProcessor> postProcessors, BeanDefinitionRegistry registry) {

	for (BeanDefinitionRegistryPostProcessor postProcessor : postProcessors) {
		postProcessor.postProcessBeanDefinitionRegistry(registry);
	}
}

# BeanFactoryPostProcessor.class
invokeBeanFactoryPostProcessorså¯ä»¥è¦†ç›–å’Œaddå±æ€§å€¼ï¼Œç”šè‡³æ˜¯å®ä¾‹åŒ–bean
private static void invokeBeanFactoryPostProcessors(
		Collection<? extends BeanFactoryPostProcessor> postProcessors, ConfigurableListableBeanFactory beanFactory) {

	for (BeanFactoryPostProcessor postProcessor : postProcessors) {
		postProcessor.postProcessBeanFactory(beanFactory);
	}
}

----
ä¸‹é¢å°±æ˜¯è¿›å…¥å„ä¸ªBeanDefinitionRegistryPostProcessorå’ŒBeanFactoryPostProcessorè‡ªå·±çš„æ–¹æ³•èµ°é€»è¾‘äº†ï¼Œä¸å†è¯¦è¿°

ä¸‹é¢è¯´ä¸‹PostProcessorRegistrationDelegateç±»ï¼Œä»–æ˜¯AbstractApplicationContextçš„å§”æ‰˜ç±»ï¼Œä¸“é—¨è´Ÿè´£post-processorå¤„ç†ï¼Œåˆ«çœ‹è¿™ä¸ªç±»ä»£ç æŒºå¤šï¼Œä½†åŠŸèƒ½æ€§å´å¾ˆç®€å•ï¼Œåªæœ‰ä¸¤ä¸ªpublicæ–¹æ³•ï¼Œå³å¹²ä¸¤ä»¶äº‹: <font color=green>invoke BeanFactoryPostProcessor(å­ç±»ç•¥)å’Œregistry BeanPostProcessors to AbstractBeanFactory.beanPostProcessorså±æ€§(æ³¨å†Œé¡ºåºåŒBeanFactoryPostProcessorè°ƒç”¨é¡ºåº)</font>ã€‚ä½†æ˜¯è¿™ä¸¤ä»¶äº‹éƒ½å¾ˆé‡è¦