= ç»†èŠ‚çŸ¥å¤šå°‘ - spring @Valueæ³¨è§£è§£æ
:toc: left
:toc-title: ç›®å½•
:tip-caption: ğŸ’¡
:note-caption: â„¹ï¸
:important-caption: â—
:caution-caption: ğŸ”¥
:warning-caption: âš ï¸
// :tip-caption: :bulb:
// :note-caption: :information_source:
// :important-caption: :heavy_exclamation_mark:	
// :caution-caption: :fire:
// :warning-caption: :warning:
:icons: font

Doc writer yaoyihao1@gmail.com

== ç¼˜ç”±

â€‹`@Value` æ˜¯å¼€å‘è¿‡ç¨‹ä¸­ä½¿ç”¨æ¯”è¾ƒé¢‘ç¹çš„æ³¨è§£ä¹‹ä¸€ï¼Œå®ƒçš„ä½œç”¨æ˜¯å°†é…ç½®æ–‡ä»¶ä¸­keyå¯¹åº”çš„å€¼èµ‹å€¼ç»™å®ƒæ ‡æ³¨çš„å±æ€§ã€‚å¯¹äºå¸¸è§çš„çŸ¥è¯†ç‚¹ï¼Œæˆ‘ä»¬åº”è¯¥äº†è§£å®ƒåŠŸèƒ½å®ç°çš„æœ¬è´¨ã€‚å¯¹æˆ‘ä»¬è‡ªå·±çš„æŠ€æœ¯æå‡å¾ˆæœ‰å¸®åŠ©ã€‚

== åŸç†

â€‹åœ¨springä¸­æ˜¯ç”± `AutowiredAnnotationBeanPostProcessor` è§£æå¤„ç† `@Value` æ³¨è§£ã€‚ `AutowiredAnnotationBeanPostProcessor` æ˜¯ä¸€ä¸ª `BeanPostProcessor` ï¼Œæ‰€ä»¥æ¯ä¸ªç±»çš„å®ä¾‹åŒ–éƒ½è¿‡ç»è¿‡ `AutowiredAnnotationBeanPostProcessor` ç±»ã€‚å½“ `post-processor` å¤„ç†beanæ—¶ï¼Œä¼šè§£æbean Classçš„æ‰€æœ‰å±æ€§ï¼Œåœ¨è§£ææ—¶ä¼šåˆ¤æ–­å±æ€§ä¸Šæ˜¯å¦æ ‡æœ‰ `@Value` æ³¨è§£ï¼Œæœ‰å°±è§£æè¿™ä¸ª `@Value` çš„å±æ€§å€¼ï¼Œå°†è§£æåç»“æœæ”¾å…¥ `AutowiredFieldElement` ç±»å‹ `InjectionMetaData.checkedElements` ä¸­ï¼Œå½“ç»™å±æ€§èµ‹å€¼æ—¶ä¼šä½¿ç”¨ `checkedElements` ï¼Œä»è€Œå¾—åˆ° `@Value` æ³¨è§£çš„ `Filed` å±æ€§ï¼Œè°ƒç”¨ `AutowiredFieldElement.inject()` æ–¹æ³•è¿›è¡Œè§£æï¼Œè§£ææ—¶ä¼šä½¿ç”¨ `DefaultListableBeanFactory` (ç”¨äºè§£æ${})å’Œ `TypeConverter` (ç”¨äºç±»å‹è½¬æ¢)ï¼Œä»è€Œå¾—åˆ° `age` å±æ€§çš„å€¼ï¼Œæœ€åè°ƒç”¨ `field.set(bean, value)` ï¼Œä»è€Œè·å–çš„å€¼èµ‹ç»™ `beançš„field`ã€‚

â€‹æ•´ä¸ªè¿‡ç¨‹å°±æ˜¯è¿™æ ·ï¼Œæœ‰ç‚¹æŠ½è±¡å§ï¼Œä¸‹é¢æˆ‘ä»¬ä¸€èµ·debugæºç ï¼Œæ›´æ¸…æ™°ç®€æ˜çš„äº†è§£@Valueçš„åŸç†ã€‚


> debugæºç æ˜¯æˆ‘è§‰å¾—æŒæ¡å…¶åŸç†æœ€å¥½çš„æ–¹å¼



== å‡†å¤‡

1. ä¸€ä¸ªå¯ä»¥è¿è¡Œçš„spring boot project
2. æä¾›ä¸€ä¸ªcontrollerç±»ï¼ŒåŒ…å«ä¸€ä¸ªè¢«@Valueæ ‡æ³¨çš„å±æ€§ï¼š`int age`

----
@RestController
@Slf4j
public class MyController {

    @Value("${user.age:11}")
    private int age;
  
    public int getAge(){
        log.info("age:{}", age)
        return age;
    }
}
----



== ä¸€èµ·debugè§£å¼€ç¥ç§˜

=== å…¥å£ 

> æ ¸å¿ƒï¼šå­˜ã€‚å°†classçš„æ ‡æ³¨@Valueçš„æ‰€æœ‰ä¿¡æ¯è½¬å­˜InjectionMetadata.InjectedElementé›†åˆä¸­

`@Value` åŒ@ `Autowired` ä¸€æ ·ï¼Œæ˜¯ç”± `AutowiredAnnotationBeanPostProcessor` è§£æå¤„ç†ï¼Œå¤„ç† `@Value` çš„å…¥å£ä¸º `AutowiredAnnotationBeanPostProcessor.buildAutowiringMetadata(Class clazz)` ã€‚çœ‹ä»£ç å†…éƒ¨

----
AutowiredAnnotationBeanPostProcessor class
private InjectionMetadata buildAutowiringMetadata(final Class<?> clazz) {
    List<InjectionMetadata.InjectedElement> elements = new ArrayList<>();
    Class<?> targetClass = clazz;

    do {
        final List<InjectionMetadata.InjectedElement> currElements = new ArrayList<>();

        // è§£ætargetClassçš„æ‰€æœ‰å±æ€§
        ReflectionUtils.doWithLocalFields(targetClass, field -> {
            AnnotationAttributes ann = findAutowiredAnnotation(field);
            if (ann != null) {
                // ç”±æ­¤å¯çŸ¥ï¼Œstaticä¿®æ”¹çš„å±æ€§æ— æ³•ä½¿ç”¨@Valueæ³¨è§£èµ‹å€¼
                if (Modifier.isStatic(field.getModifiers())) {
                    return;
                }
                boolean required = determineRequiredStatus(ann);
                currElements.add(new AutowiredFieldElement(field, required));
            }
        });

        ReflectionUtils.doWithLocalMethods(targetClass, method -> {
            Method bridgedMethod = BridgeMethodResolver.findBridgedMethod(method);
            AnnotationAttributes ann = findAutowiredAnnotation(bridgedMethod);
            if (ann != null && method.equals(ClassUtils.getMostSpecificMethod(method, clazz))) {
                // ç”±æ­¤å¯çŸ¥ï¼Œstaticä¿®æ”¹çš„æ–¹æ³•æ— æ³•ä½¿ç”¨@Valueæ³¨è§£èµ‹å€¼
                if (Modifier.isStatic(method.getModifiers())) {
                    return;
                }
                boolean required = determineRequiredStatus(ann);
                PropertyDescriptor pd = BeanUtils.findPropertyForMethod(bridgedMethod, clazz);
                currElements.add(new AutowiredMethodElement(method, required, pd));
            }
        });

        elements.addAll(0, currElements);
        targetClass = targetClass.getSuperclass();
    }
    while (targetClass != null && targetClass != Object.class);

    return new InjectionMetadata(clazz, elements);
}
----

è¿™ä¸ªæ–¹æ³•ç”¨äºéå†å’Œè§£æclazzçš„æ‰€æœ‰filedå’Œmethodï¼Œè§£æå…¶ä¸Šçš„ `@Value` ã€ `@Autowired` ã€ `@Inject` æ³¨è§£ï¼Œç„¶åæ”¾å…¥ç±»å‹ä¸º `InjectionMetadata.InjectedElement` çš„ `elements` ä¸­ï¼Œ `elements` å†æ”¾å…¥ `metadata(=new InjectionMetadata(clazz, elements))` ä¸­ã€‚å†å°† `metadata` æ”¾å…¥ç¼“å­˜ `injectionMetadataCache` ä¸­ï¼Œåé¢ä¼šä»ç¼“å­˜ä¸­å–å€¼

ä¸‹é¢ï¼Œæˆ‘ä»¬é‡ç‚¹çœ‹å±æ€§çš„è§£æè¿‡ç¨‹ï¼Œä»£ç å¦‚ä¸‹

----
AutowiredAnnotationBeanPostProcessor class
private AnnotationAttributes findAutowiredAnnotation(AccessibleObject ao) {
    if (ao.getAnnotations().length > 0) {  // autowiring annotations have to be local
        for (Class<? extends Annotation> type : this.autowiredAnnotationTypes) {
            AnnotationAttributes attributes = AnnotatedElementUtils.getMergedAnnotationAttributes(ao, type);
            if (attributes != null) {
                return attributes;
            }
        }
    }
    return null;
}
----

`autowiredAnnotationTypes` åŒ…å«äº† `@Value` ã€ `@Autowired` ã€ `@Inject` ã€‚å¦‚æœå±æ€§è§£æåˆ°äº†å“åº”æ³¨è§£ï¼Œå°±å°†æ³¨è§£çš„ä¿¡æ¯è¿”å›ç»™ä¸Šå±‚ã€‚è§£ææ³¨è§£è¿‡ç¨‹è¿™é‡Œä¸è¯¦ç»†è¯´äº†



=== è§£æ

> æ ¸å¿ƒï¼šä½¿ç”¨InjectionMetadata.InjectedElementï¼Œè§£æå¹¶èµ‹å€¼ç»™clazzçš„å±æ€§ï¼Œå³èµ‹å€¼MyController.age

ä¸Šé¢çš„é€»è¾‘ä¸»è¦ä¸ºè§£æ@Valueçš„ä¿¡æ¯å­˜å…¥ `InjectionMetadata.InjectedElement` é›†åˆï¼Œä¸‹é¢çš„é€»è¾‘ä¸ºä½¿ç”¨ `InjectionMetadata.InjectedElement` ï¼Œè§£æå‡ºçœŸæ­£çš„å€¼ï¼Œä»è€Œèµ‹å€¼ç»™å±æ€§ã€‚ä¸‹é¢çœ‹çœ‹æ€ä¹ˆè§£æå¹¶èµ‹å€¼çš„



é¦–å…ˆï¼Œæˆ‘ä»¬é€šè¿‡è·å– `InjectionMetadata.InjectedElement` å¯¹è±¡æ•°æ®ï¼Œå…¶å®æ˜¯ä» `injectionMetadataCache` ç¼“å­˜ä¸­è·å–çš„ã€‚è·å–çš„åœ°ç‚¹ä»£ç å¦‚ä¸‹

----
AutowiredAnnotationBeanPostProcessor class
public PropertyValues postProcessProperties(PropertyValues pvs, Object bean, String beanName) {
    // è·å–ï¼Œä»injectionMetadataCacheç¼“å­˜è·å–
    InjectionMetadata metadata = findAutowiringMetadata(beanName, bean.getClass(), pvs);
    // ä½¿ç”¨
    metadata.inject(bean, beanName, pvs);
    return pvs;
}
----

æˆ‘ä»¬é‡ç‚¹çœ‹ä½¿ç”¨éƒ¨åˆ†ï¼Œå³`metadata.inject(bean, beanName, pvs)`ï¼Œçœ‹æ–¹æ³•åå°±çŸ¥é“ï¼Œè¦æ³¨å…¥å±æ€§å€¼ã€‚çœ‹ä»£ç å†…éƒ¨

----
InjectionMetadata class
public void inject(Object target, @Nullable String beanName, @Nullable PropertyValues pvs) {
    if (!checkedElements.isEmpty()) {
        for (InjectedElement element : checkedElements) {
            element.inject(target, beanName, pvs);
        }
    }
}
----

æ–¹æ³•é€»è¾‘å¾ˆç®€å•ï¼Œéå†é›†åˆåˆ†åˆ«è°ƒç”¨ `inject()` æ–¹æ³•ã€‚çœ‹å…¶å†…éƒ¨ä»£ç é€»è¾‘

----
InjectionMetadata.InjectedElement class
protected void inject(Object bean, @Nullable String beanName, @Nullable PropertyValues pvs) {
    Field field = (Field) this.member;
    Object value;
    if (this.cached) {
        value = resolvedCachedArgument(beanName, this.cachedFieldValue);
    }
    else {
        DependencyDescriptor desc = new DependencyDescriptor(field, this.required);
        desc.setContainingClass(bean.getClass());
        Set<String> autowiredBeanNames = new LinkedHashSet<>(1);
        // è·å–ç±»å‹è½¬æ¢å™¨
        TypeConverter typeConverter = beanFactory.getTypeConverter();
        // æ ¸å¿ƒé€»è¾‘ï¼šè§£æfieldæ³¨è§£
        value = beanFactory.resolveDependency(desc, beanName, autowiredBeanNames, typeConverter);
        // Â·Â·Â· å€¼ç¼“å­˜èµ·æ¥ ç•¥
    }
    if (value != null) {
        ReflectionUtils.makeAccessible(field);
        field.set(bean, value);
    }
    
}
----

æ–¹æ³•çš„æ ¸å¿ƒä¸ºä½¿ç”¨ `DependencyDescriptor` åŒ…è£…fieldï¼Œä½¿ç”¨ `beanFactory` è§£æ `DependencyDescriptor` ä»è€Œå¾—åˆ°å±æ€§å€¼ã€‚ä¸‹é¢çœ‹å…¶ `beanFactory.resolveDependency()` å†…éƒ¨ä»£ç ã€‚(æ³¨ï¼š `beanFactory` æ˜¯é€šè¿‡ `BeanFactoryAware` æ³¨å…¥çš„ï¼Œæˆ‘ä»¬å¯å­¦ä¹ è¿™ç§ç”¨æ³•)

----
DefaultListableBeanFactory class
public Object resolveDependency(DependencyDescriptor descriptor, @Nullable String requestingBeanName,
			@Nullable Set<String> autowiredBeanNames, @Nullable TypeConverter typeConverter) {

    descriptor.initParameterNameDiscovery(getParameterNameDiscoverer());
    // å¤„ç†Optionalç±»å‹çš„fieldï¼Œä¸@Valueæ— å…³ï¼Œæš‚ç•¥
    if (Optional.class == descriptor.getDependencyType()) {
        return createOptionalDependency(descriptor, requestingBeanName);
    }
    // å¤„ç†ObjectFactoryå’ŒObjectProviderç±»å‹çš„fieldï¼Œä¸@Valueæ— å…³ï¼Œæš‚ç•¥
    else if (ObjectFactory.class == descriptor.getDependencyType() ||
            ObjectProvider.class == descriptor.getDependencyType()) {
        return new DependencyObjectProvider(descriptor, requestingBeanName);
    }else {
        // æ ¸å¿ƒ: çœŸæ­£è§£æfieldçš„æ–¹æ³•
        result = doResolveDependency(descriptor, requestingBeanName, autowiredBeanNames, typeConverter);
        return result;
    }
}
----

ä»æ–¹æ³•çš„å…¥å‚å¯ä»¥çœ‹åˆ°ï¼Œè¿™ä¸ªç±»å‹è½¬æ¢å™¨ `TypeConverter` å·²ç»ä¼ è¿›æ¥äº†ï¼Œéœ€è¦ç±»å‹è½¬æ¢æ—¶å°±ä½¿ç”¨ `TypeConverter` å®ƒè¿›è¡Œè½¬æ¢ï¼Œ `TypeConverter` æ˜¯ä» `BeanFactory.getTypeConverter()` è·å–æ¥çš„ã€‚

*doResolveDependency()è§£æ@Valueæ³¨è§£çš„å¤§ç®¡å®¶ï¼Œå®ƒä¸è´Ÿè´£å…·ä½“è§£æï¼Œä½†å®ƒè¯´æ˜äº†è§£æçš„æ•´ä¸ªæµç¨‹* ã€‚çœ‹ `doResolveDependency()` æ–¹æ³•ä»£ç é€»è¾‘

----
DefaultListableBeanFactory class
public Object doResolveDependency(DependencyDescriptor descriptor, @Nullable String beanName,
			@Nullable Set<String> autowiredBeanNames, @Nullable TypeConverter typeConverter) {

    InjectionPoint previousInjectionPoint = ConstructorResolver.setCurrentInjectionPoint(descriptor);
    try {
        // fieldå±æ€§çš„ç±»å‹
        Class<?> type = descriptor.getDependencyType();
        // 1. è·å–(ä¸åªæ˜¯)@Valueæ³¨è§£çš„valueæ–¹æ³•çš„å€¼ å¦‚æ­¤ä¾‹ä¸­valueæ–¹æ³•å€¼ä¸º: ${test.age:11}      (1)
        Object value = getAutowireCandidateResolver().getSuggestedValue(descriptor);
        if (value != null) {
            // å¦‚æœvalueæ˜¯Stringç±»å‹ï¼Œèµ°è¿™é‡Œã€‚æ­¤ä¾‹valueä¸º: ${test.age:11}å­—ç¬¦ä¸²
            if (value instanceof String) {
                // 2. å¼€å§‹è§£ævalueçš„å€¼ 
                String strVal = resolveEmbeddedValue((String) value);
                BeanDefinition bd = (beanName != null && containsBean(beanName) ?
                        getMergedBeanDefinition(beanName) : null);
                value = evaluateBeanDefinitionString(strVal, bd);
            }
            TypeConverter converter = (typeConverter != null ? typeConverter : getTypeConverter());
            try {
                // 3. å¼€å§‹è§£ævalueçš„å€¼ 
                return converter.convertIfNecessary(value, type, descriptor.getTypeDescriptor());
            }
            catch (UnsupportedOperationException ex) {
                ...
            }
        }
        ... çœç•¥è§£æ@Autowiredæ³¨è§£çš„é€»è¾‘
    }finally {
        ConstructorResolver.setCurrentInjectionPoint(previousInjectionPoint);
    }
}
----



æ­¤æ–¹æ³•ä¸ºè§£æ `@Value` æ³¨è§£å±æ€§å€¼çš„æ ¸å¿ƒæ–¹æ³•äº†ã€‚é€»è¾‘åˆ†ä¸ºå››æ­¥ï¼š

1. è·å–(ä¸åªæ˜¯) `@Value` æ³¨è§£çš„valueæ–¹æ³•çš„å€¼ã€‚é€šè¿‡ `descriptor` è§£æå‡ºæ³¨è§£çš„ `valueæ–¹æ³•` çš„å€¼
2. å¼€å§‹è§£ævalueçš„å€¼
3. å¦‚æœå€¼ä¸ºStringç±»å‹ï¼Œä¼šç‰¹æ®Šçš„è§£æè¿™ä¸ªå€¼ï¼Œç‰¹æ®Šè§£æçš„æ„æ€æ˜¯å¦‚æœå€¼ä¸º `${test.age:11}` ï¼Œä¼šè§£æå‡ºå€¼ä¸º:  `"11"` ï¼Œè¿™ä¸ªè§£æè¿‡ç¨‹ä½¿ç”¨çš„æ˜¯ `PropertySourcesPlaceholderConfigurer.processProperties()` æ–¹æ³•

è¯´çš„æœ‰ç‚¹æŠ½è±¡ï¼Œä¸¾ä¸ªä¾‹å­ã€‚å¦‚ä¸‹ï¼Œå®šä¹‰äº†ä¸€ä¸ª@Valueæ³¨è§£çš„å˜é‡

----
@Value("${user.age:11}")
private int age;

ç¬¬ä¸€æ­¥ï¼šé€šè¿‡descriptorå¾—åˆ°${user.age:11}
ç¬¬äºŒæ­¥ï¼šæ‹†è§£${user.age:11}ï¼Œå¾—åˆ°user.age:11ï¼Œè·å–å€¼ï¼Œæ²¡æœ‰è·å–åˆ°ï¼Œä»¥:æˆ–${}ä¸ºæ ‡å‡†å†æ‹†è§£ï¼Œæœ€åå¾—åˆ°å€¼
ç¬¬ä¸‰æ­¥ï¼šæ­¤æ—¶å¾—åˆ°çš„å€¼æ˜¯Stringç±»å‹çš„ï¼Œéœ€è¦è½¬æ¢æˆç›®æ ‡å˜é‡å£°æ˜çš„ç±»å‹ï¼Œæ­¤å¤„ç±»å‹ä¸ºint
----



==== one step

é¦–å…ˆè¯¦ç»†äº†è§£ä¸‹ç¬¬ä¸€æ­¥ã€‚è·å– `@Valueçš„value()` æ–¹æ³•çš„å€¼

----

QualifierAnnotationAutowireCandidateResolver class
public Object getSuggestedValue(DependencyDescriptor descriptor) {
		Object value = findValue(descriptor.getAnnotations());
    if (value == null) {
        MethodParameter methodParam = descriptor.getMethodParameter();
        if (methodParam != null) {
            value = findValue(methodParam.getMethodAnnotations());
        }
    }
    return value;
}
protected Object findValue(Annotation[] annotationsToSearch) {
    if (annotationsToSearch.length > 0) {   // qualifier annotations have to be local
        AnnotationAttributes attr = AnnotatedElementUtils.getMergedAnnotationAttributes(
                AnnotatedElementUtils.forAnnotations(annotationsToSearch), this.valueAnnotationType);
        if (attr != null) {
            return extractValue(attr);
        }
    }
    return null;
}	

----

ä»¥ä¸Šä¸¤ä¸ªæ–¹æ³•ä¸»è¦æ˜¯è§£æ `@Value` æ³¨è§£ï¼Œå†é€šè¿‡ `AnnotatedElementUtils.getMergedAnnotationAttributes()` æ–¹æ³•å¾—åˆ°æ³¨è§£çš„å±æ€§é›†åˆï¼Œä»è€Œè·å–åˆ° `value()` æ–¹æ³•çš„å€¼

==== two step

è§£æä¼ å…¥çš„ `${key:defaultValue}` å½¢å¼çš„å­—ç¬¦ä¸²ï¼Œä»è€Œå¾—åˆ°keyçš„å®é™…çš„å€¼ã€‚

----
public String resolveEmbeddedValue(@Nullable String value) {
    String result = value;
    for (StringValueResolver resolver : this.embeddedValueResolvers) {
        result = resolver.resolveStringValue(result);
        return result;
    }
}
----

æ ¸å¿ƒæ–¹æ³•ä¸º `resolver.resolveStringValue(result)` æ–¹æ³•ï¼Œresolverå®é™…ä¸º `StringValueResolverç±»å‹çš„lambdaè¡¨è¾¾å¼` ï¼Œè¿™ä¸ªè¡¨ç¤ºå¼å®šä¹‰åœ¨äº† `PropertySourcesPlaceHolderConfigurer.processProperties()` æ–¹æ³•ä¸­ï¼Œè¿™é‡Œdebugæ˜¯éœ€è¦æ³¨æ„ä¸‹ï¼Œå¦‚æœä½ ä¸äº†è§£lambdaï¼Œå¯èƒ½ä¼šæ¯”è¾ƒæœ¦èƒ§ã€‚ä»£ç å¦‚ä¸‹

----
PropertySourcesPlaceHolderConfigurer class
protected void processProperties(ConfigurableListableBeanFactory beanFactoryToProcess,
			final ConfigurablePropertyResolver propertyResolver) throws BeansException {

    propertyResolver.setPlaceholderPrefix(this.placeholderPrefix);
    propertyResolver.setPlaceholderSuffix(this.placeholderSuffix);
    propertyResolver.setValueSeparator(this.valueSeparator);

    StringValueResolver valueResolver = strVal -> {
        String resolved = (this.ignoreUnresolvablePlaceholders ?
                propertyResolver.resolvePlaceholders(strVal) :
                propertyResolver.resolveRequiredPlaceholders(strVal));
        if (this.trimValues) {
            resolved = resolved.trim();
        }
        return (resolved.equals(this.nullValue) ? null : resolved);
    };

    doProcessProperties(beanFactoryToProcess, valueResolver);
}
----

lambdaä¼šæ‰°ä¹±ä½ çš„è°ƒç”¨æ ˆå±•ç¤ºï¼Œä¸‹é¢æˆªå›¾å±•ç¤ºçœŸå®è°ƒç”¨æ ˆçš„ä¿¡æ¯

image::https://raw.githubusercontent.com/yaoyuanyy/MarkdownPhotos/master/img/20201029203940.png[20201029203940]

ä¸Šé¢ä»£ç ä¸­ `processProperties` æ–¹æ³•ä¼šè°ƒç”¨ `PropertySourcesPropertyResolver.resolveRequiredPlaceholders()` æ–¹æ³•æ¥è§£æå…¥å‚ï¼Œè€Œå®ƒåˆä¼šè°ƒç”¨ `PropertySourcesPropertyResolver.getPropertyAsRawString()` å’Œ `PropertyPlaceholderHelper.replacePlaceholders()` ã€‚ä»£ç å¦‚ä¸‹

----
AbstractPropertyResoler class
public String resolveRequiredPlaceholders(String text) throws IllegalArgumentException {
    if (this.strictHelper == null) {
        this.strictHelper = createPlaceholderHelper(false);
    }
    return doResolvePlaceholders(text, this.strictHelper);
}

private String doResolvePlaceholders(String text, PropertyPlaceholderHelper helper) {
    return helper.replacePlaceholders(text, this::getPropertyAsRawString);
}
----

=== PropertySourcesPropertyResolver.getPropertyAsRawString()æ–¹æ³•é€»è¾‘

`PropertySourcesPropertyResolver.getPropertyAsRawString()` è´Ÿè´£è·å–keyçš„å€¼ï¼Œå› ä¸º `PropertySourcesPropertyResolver.æŒæœ‰propertySourceså˜é‡` ï¼Œè¿™ä¸ªå˜é‡ä¸ `Environmentçš„propertySources` å˜é‡æ˜¯åŒæ­¥çš„ï¼Œæ‰€ä»¥ `propertySource.getProperty(key)` å¯ä»¥è·å–åˆ°é…ç½®æ–‡ä»¶ä¸­çš„å€¼ï¼Œä»£ç å¦‚ä¸‹

----
PropertySourcesPropertyResolver class
protected String getPropertyAsRawString(String key) {
    return getProperty(key, String.class, false);
}
	
protected <T> T getProperty(String key, Class<T> targetValueType, boolean resolveNestedPlaceholders) {
    if (this.propertySources != null) {
        for (PropertySource<?> propertySource : this.propertySources) {
            if (logger.isTraceEnabled()) {
                logger.trace("Searching for key '" + key + "' in PropertySource '" +
                        propertySource.getName() + "'");
            }
            Object value = propertySource.getProperty(key);
            if (value != null) {
                if (resolveNestedPlaceholders && value instanceof String) {
                    value = resolveNestedPlaceholders((String) value);
                }
                logKeyFound(key, propertySource, value);
                return convertValueIfNecessary(value, targetValueType);
            }
        }
    }
    return null;
}
----

å¯ä»¥çœ‹åˆ°ï¼Œæœ€å `propertySource.getProperty(key)` è·å–å€¼è¿”å›ã€‚

=== PropertyPlaceholderHelper.replacePlaceholders()æ–¹æ³•é€»è¾‘

`PropertyPlaceholderHelper.replacePlaceholders()` è´Ÿè´£è§£æ `${key: defaultValue}` ï¼Œå°†å®ƒæ‹†è§£ä»¥è·å–keyï¼Œå†ç”¨ `propertySource.getProperty(key)` è·å–å€¼ã€‚è€Œå…·ä½“çš„æ‹†è§£é€»è¾‘åœ¨ `parseStringValue()` æ–¹æ³•ä¸­ï¼Œä»£ç å¦‚ä¸‹

----
public String replacePlaceholders(String value, PlaceholderResolver placeholderResolver) {
    Assert.notNull(value, "'value' must not be null");
    return parseStringValue(value, placeholderResolver, null);
}

protected String parseStringValue(
			String value, PlaceholderResolver placeholderResolver, @Nullable Set<String> visitedPlaceholders) {

    int startIndex = value.indexOf(this.placeholderPrefix);
    if (startIndex == -1) {
        return value;
    }

    StringBuilder result = new StringBuilder(value);
    while (startIndex != -1) {
        ... ç•¥ å…·ä½“æ‹†è§£${xx:yy},ä¸å±•ç¤ºäº†ï¼Œè‡ªå·±æ¥çœ‹å§ï¼Œå¦åˆ™ä»£ç å¤ªå¤šå½±å“äº†è¦ä¸»è¦çš„é€»è¾‘
            // é€’å½’è°ƒç”¨
            placeholder = parseStringValue(placeholder, placeholderResolver, visitedPlaceholders);
            // è·å–placeholderå®é™…ä¸ºkeyï¼Œæœ€ç»ˆè°ƒç”¨propertySource.getProperty(key)è·å–å€¼
            String propVal = placeholderResolver.resolvePlaceholder(placeholder);
        ... ç•¥ åŒä¸Š
    }	
    return result.toString();
}
----



å¯ä»¥çœ‹åˆ°è¿™ä¸ªkeyä¸€ä¸ªæ‹†è§£ä¸€å±‚å¾—åˆ°ä¸€ä¸ªæ–°keyï¼Œå°è¯•è°ƒç”¨ `placeholderResolver.resolvePlaceholder(æ–°key)` è·å–å€¼ï¼Œå¦‚æœæ²¡æœ‰è·å–åˆ°ï¼Œå†æ‹†è§£ä¸€å±‚å¾—åˆ°ä¸€ä¸ªæ–°keyï¼Œå†è°ƒç”¨ `placeholderResolver.resolvePlaceholder(æ–°key)` è·å–å€¼çš„å¾ªç¯è¿‡ç¨‹ï¼Œç›´åˆ°è·å–åˆ°è·å–ä¸èƒ½æ‹†è§£ä¸ºæ­¢çš„è¿‡ç¨‹(å› ä¸ºkeyçš„å½¢å¼å¯ä»¥æ˜¯${xx:${yy:zz}})ã€‚æ­¤æ—¶å¾—åˆ°çš„å€¼æ—¶Stringç±»å‹çš„ã€‚å¹¶ä¸æ˜¯æˆ‘ä»¬èµ‹å€¼å˜é‡çš„ç±»å‹ï¼Œæ‰€ä»¥æ¥ä¸‹æ¥è¿›è¡Œç±»å‹è½¬æ¢ã€‚

=== Three step

å°†Stringç±»å‹çš„å€¼è½¬æ¢æˆç›®æ ‡å˜é‡å£°æ˜çš„ç±»å‹ã€‚

æˆ‘ä»¬å›åˆ° `DefaultListableBeanFactory.doResolveDependency()` æ–¹æ³•ï¼Œæ­¤æ—¶ä»£ç æ¥åˆ°äº† `converter.convertIfNecessary` æ–¹æ³•å¤„ï¼Œå³ç±»å‹è½¬æ¢ã€‚çœ‹æ–¹æ³•ä»£ç 

----
TypeConverterSupport class
public <T> T convertIfNecessary(@Nullable Object value, @Nullable Class<T> requiredType,
        @Nullable TypeDescriptor typeDescriptor) throws TypeMismatchException {
    return this.typeConverterDelegate.convertIfNecessary(null, null, value, requiredType, typeDescriptor);
}

TypeConverterDelegate class
public <T> T convertIfNecessary(@Nullable String propertyName, @Nullable Object oldValue, @Nullable Object newValue,
			@Nullable Class<T> requiredType, @Nullable TypeDescriptor typeDescriptor)  {
    // conversionServiceåŒ…å«ç€æ‰€æœ‰çš„è½¬æ¢å™¨ï¼Œå¦‚ä¸‹å›¾
    ConversionService conversionService = this.propertyEditorRegistry.getConversionService();
    TypeDescriptor sourceTypeDesc = TypeDescriptor.forObject(newValue);
    if (conversionService.canConvert(sourceTypeDesc, typeDescriptor)) {
        return (T) conversionService.convert(newValue, sourceTypeDesc, typeDescriptor);
    }
}
----

image::https://raw.githubusercontent.com/yaoyuanyy/MarkdownPhotos/master/img/20201029204039.png[20201029204039]

æ–¹æ³•é¦–å…ˆæ‰¾åˆ°èƒ½è½¬æ¢(string -> int)çš„è½¬æ¢å™¨ï¼Œç„¶åå¼€å§‹è½¬æ¢ã€‚æ€ä¹ˆæ‰¾åˆ°èƒ½è½¬æ¢çš„è½¬æ¢å™¨è¿™é‡Œä¸è¯´äº†ï¼Œè‡ªå·±è·Ÿä¸‹å§ã€‚å¼€å§‹è½¬æ¢çš„æ ¸å¿ƒæ˜¯ç¡®å®šå¯¹åº”çš„ `xxxtoyyyConverter` ,  `xxxtoyyyConverter` å†…éƒ¨è°ƒç”¨çš„æ˜¯æœ¬è´¨çš„å·¥å…·ç±»ã€‚å¦‚Stringè½¬intï¼Œå·¥å…·ç±»ä¸º:  `NumberUtils.parseNumber(source, this.targetType)` ï¼Œè¿™ä¸ªå·¥å…·ç±»æ–¹æ³•æ¯”è¾ƒç†Ÿæ‚‰å’Œäº²åˆ‡å§ï¼Œæ‰€ä»¥springå¾ˆå¤šåŠŸèƒ½æœ€ç»ˆéƒ½æ˜¯è°ƒç”¨æœ€æœ¬è´¨çš„javaå·¥å…·ç±»ã€‚ `xxxtoyyyConverter` æ˜¯ä¸€å¤§å †çš„ï¼Œå¦‚ä¸‹å›¾

image::https://raw.githubusercontent.com/yaoyuanyy/MarkdownPhotos/master/img/20201029204117.png[20201029204117]


ä»¥ä¸Šå°±æ˜¯å°† `@Value` ä¿®é¥°çš„å˜é‡èµ‹å€¼çš„æ•´ä¸ªè¿‡ç¨‹äº†ï¼Œä»è§£ææ³¨è§£çš„ `value()` æ–¹æ³•çš„å€¼keyï¼Œå†åˆ°è§£ækeyä¸ºæ–°keyï¼Œå†åˆ°é…ç½®æ–‡ä»¶è·å–key(æ–°key)çš„å€¼ï¼Œæœ€åå¯¹è·å–çš„å€¼è¿›è¡Œç±»å‹è½¬æ¢ï¼Œæœ€æœ€åé€šè¿‡ `field.set(bean, value)` èµ‹å€¼ç»™ç›®æ ‡å˜é‡



ä¸‹é¢å°†æ•´ä¸ªè§£æè¿‡ç¨‹çš„è°ƒç”¨æ ˆç½—åˆ—ä¸‹

=== æ•´ä½“è°ƒç”¨æ ˆ

----
AbstractAutowireCapableBeanFactory.createBean()                                    
-AbstractAutowireCapableBeanFactory.doCreateBean()                               
--AbstractAutowireCapableBeanFactory.applyMergedBeanDefinitionPostProcessors()   
---AutowiredAnnotationBeanPostProcessor.postProcessMergedBeanDefinition()        
----AutowiredAnnotationBeanPostProcessor.findAutowiringMetadata()                
-----AutowiredAnnotationBeanPostProcessor.buildAutowiringMetadata() 
========ä»¥ä¸Šæ˜¯å­˜é€»è¾‘ï¼Œä»¥ä¸‹æ˜¯ç”¨é€»è¾‘========
--AbstractAutowireCapableBeanFactory.populateBean()                               
---AutowiredAnnotationBeanPostProcessor.postProcessProperties()                  
----AutowiredAnnotationBeanPostProcessor.findAutowiringMetadata()                
-----InjectionMetadata.inject()                                                  
------(InjectionMetadata.InjectedElement)AutowiredFieldElement.inject()
-------DefaultListableBeanFactory.resolveDependency()
--------DefaultListableBeanFactory.doResolveDependency() ---æ ¸å¿ƒ
---------AbstractBeanFactory.resolveEmbeddedValue()
----------StringValueResolver lambdaå­ç±».resolveStringValue()
-----------PropertySourcesPropertyResolver.resolveRequiredPlaceholders()
------------AbstractPropertyResolver.getPropertyAsRawString()
-------------PropertyPlaceholderHelper.replacePlaceholders()
--------------PropertySource.getProperty()
-----------PropertyPlaceholderHelper.parseStringValue() é€’å½’
------------AbstractPropertyResolver.resolvePlaceholder()
-------------PropertySource.getProperty()
---------SimpleTypeConverter.convertIfNecessary()
----------TypeConverterDelegate.convertIfNecessarT()
-----------ConversionService.canConvert()
-----------ConversionService.convert()

----